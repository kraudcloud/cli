// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/discord-gophers/goapi-gen version v0.2.2 DO NOT EDIT.
package api

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/render"
)

// Defines values for ContainerStateStatus.
var (
	UnknownContainerStateStatus = ContainerStateStatus{}

	ContainerStateStatusCreated = ContainerStateStatus{"created"}

	ContainerStateStatusDead = ContainerStateStatus{"dead"}

	ContainerStateStatusExited = ContainerStateStatus{"exited"}

	ContainerStateStatusPaused = ContainerStateStatus{"paused"}

	ContainerStateStatusRemoving = ContainerStateStatus{"removing"}

	ContainerStateStatusRestarting = ContainerStateStatus{"restarting"}

	ContainerStateStatusRunning = ContainerStateStatus{"running"}
)

// Defines values for EndpointPortConfigProtocol.
var (
	UnknownEndpointPortConfigProtocol = EndpointPortConfigProtocol{}

	EndpointPortConfigProtocolSctp = EndpointPortConfigProtocol{"sctp"}

	EndpointPortConfigProtocolTCP = EndpointPortConfigProtocol{"tcp"}

	EndpointPortConfigProtocolUDP = EndpointPortConfigProtocol{"udp"}
)

// Defines values for EndpointPortConfigPublishMode.
var (
	UnknownEndpointPortConfigPublishMode = EndpointPortConfigPublishMode{}

	EndpointPortConfigPublishModeHost = EndpointPortConfigPublishMode{"host"}

	EndpointPortConfigPublishModeIngress = EndpointPortConfigPublishMode{"ingress"}
)

// Defines values for EndpointSpecMode.
var (
	UnknownEndpointSpecMode = EndpointSpecMode{}

	EndpointSpecModeDnsrr = EndpointSpecMode{"dnsrr"}

	EndpointSpecModeVip = EndpointSpecMode{"vip"}
)

// Defines values for HealthStatus.
var (
	UnknownHealthStatus = HealthStatus{}

	HealthStatusHealthy = HealthStatus{"healthy"}

	HealthStatusNone = HealthStatus{"none"}

	HealthStatusStarting = HealthStatus{"starting"}

	HealthStatusUnhealthy = HealthStatus{"unhealthy"}
)

// Defines values for HostConfigCgroupnsMode.
var (
	UnknownHostConfigCgroupnsMode = HostConfigCgroupnsMode{}

	HostConfigCgroupnsModeHost = HostConfigCgroupnsMode{"host"}

	HostConfigCgroupnsModePrivate = HostConfigCgroupnsMode{"private"}
)

// Defines values for HostConfigIsolation.
var (
	UnknownHostConfigIsolation = HostConfigIsolation{}

	HostConfigIsolationDefault = HostConfigIsolation{"default"}

	HostConfigIsolationHyperv = HostConfigIsolation{"hyperv"}

	HostConfigIsolationProcess = HostConfigIsolation{"process"}
)

// Defines values for HostConfigLogConfigType.
var (
	UnknownHostConfigLogConfigType = HostConfigLogConfigType{}

	HostConfigLogConfigTypeAwslogs = HostConfigLogConfigType{"awslogs"}

	HostConfigLogConfigTypeEtwlogs = HostConfigLogConfigType{"etwlogs"}

	HostConfigLogConfigTypeFluentd = HostConfigLogConfigType{"fluentd"}

	HostConfigLogConfigTypeGelf = HostConfigLogConfigType{"gelf"}

	HostConfigLogConfigTypeJSONFile = HostConfigLogConfigType{"json-file"}

	HostConfigLogConfigTypeJournald = HostConfigLogConfigType{"journald"}

	HostConfigLogConfigTypeNone = HostConfigLogConfigType{"none"}

	HostConfigLogConfigTypeSplunk = HostConfigLogConfigType{"splunk"}

	HostConfigLogConfigTypeSyslog = HostConfigLogConfigType{"syslog"}
)

// Defines values for LocalNodeState.
var (
	UnknownLocalNodeState = LocalNodeState{}

	LocalNodeStateActive = LocalNodeState{"active"}

	LocalNodeStateEmpty = LocalNodeState{""}

	LocalNodeStateError = LocalNodeState{"error"}

	LocalNodeStateInactive = LocalNodeState{"inactive"}

	LocalNodeStateLocked = LocalNodeState{"locked"}

	LocalNodeStatePending = LocalNodeState{"pending"}
)

// Defines values for MountBindOptionsPropagation.
var (
	UnknownMountBindOptionsPropagation = MountBindOptionsPropagation{}

	MountBindOptionsPropagationPrivate = MountBindOptionsPropagation{"private"}

	MountBindOptionsPropagationRprivate = MountBindOptionsPropagation{"rprivate"}

	MountBindOptionsPropagationRshared = MountBindOptionsPropagation{"rshared"}

	MountBindOptionsPropagationRslave = MountBindOptionsPropagation{"rslave"}

	MountBindOptionsPropagationShared = MountBindOptionsPropagation{"shared"}

	MountBindOptionsPropagationSlave = MountBindOptionsPropagation{"slave"}
)

// Defines values for MountType.
var (
	UnknownMountType = MountType{}

	MountTypeBind = MountType{"bind"}

	MountTypeNpipe = MountType{"npipe"}

	MountTypeTmpfs = MountType{"tmpfs"}

	MountTypeVolume = MountType{"volume"}
)

// Defines values for MountPointType.
var (
	UnknownMountPointType = MountPointType{}

	MountPointTypeBind = MountPointType{"bind"}

	MountPointTypeNpipe = MountPointType{"npipe"}

	MountPointTypeTmpfs = MountPointType{"tmpfs"}

	MountPointTypeVolume = MountPointType{"volume"}
)

// Defines values for NodeSpecAvailability.
var (
	UnknownNodeSpecAvailability = NodeSpecAvailability{}

	NodeSpecAvailabilityActive = NodeSpecAvailability{"active"}

	NodeSpecAvailabilityDrain = NodeSpecAvailability{"drain"}

	NodeSpecAvailabilityPause = NodeSpecAvailability{"pause"}
)

// Defines values for NodeSpecRole.
var (
	UnknownNodeSpecRole = NodeSpecRole{}

	NodeSpecRoleManager = NodeSpecRole{"manager"}

	NodeSpecRoleWorker = NodeSpecRole{"worker"}
)

// Defines values for NodeState.
var (
	UnknownNodeState = NodeState{}

	NodeStateDisconnected = NodeState{"disconnected"}

	NodeStateDown = NodeState{"down"}

	NodeStateReady = NodeState{"ready"}

	NodeStateUnknown = NodeState{"unknown"}
)

// Defines values for PortType.
var (
	UnknownPortType = PortType{}

	PortTypeSctp = PortType{"sctp"}

	PortTypeTCP = PortType{"tcp"}

	PortTypeUDP = PortType{"udp"}
)

// Defines values for Reachability.
var (
	UnknownReachability = Reachability{}

	ReachabilityReachable = Reachability{"reachable"}

	ReachabilityUnknown = Reachability{"unknown"}

	ReachabilityUnreachable = Reachability{"unreachable"}
)

// Defines values for RestartPolicyName.
var (
	UnknownRestartPolicyName = RestartPolicyName{}

	RestartPolicyNameAlways = RestartPolicyName{"always"}

	RestartPolicyNameEmpty = RestartPolicyName{""}

	RestartPolicyNameNo = RestartPolicyName{"no"}

	RestartPolicyNameOnFailure = RestartPolicyName{"on-failure"}

	RestartPolicyNameUnlessStopped = RestartPolicyName{"unless-stopped"}
)

// Defines values for ServiceSpecRollbackConfigFailureAction.
var (
	UnknownServiceSpecRollbackConfigFailureAction = ServiceSpecRollbackConfigFailureAction{}

	ServiceSpecRollbackConfigFailureActionContinue = ServiceSpecRollbackConfigFailureAction{"continue"}

	ServiceSpecRollbackConfigFailureActionPause = ServiceSpecRollbackConfigFailureAction{"pause"}
)

// Defines values for ServiceSpecRollbackConfigOrder.
var (
	UnknownServiceSpecRollbackConfigOrder = ServiceSpecRollbackConfigOrder{}

	ServiceSpecRollbackConfigOrderStartFirst = ServiceSpecRollbackConfigOrder{"start-first"}

	ServiceSpecRollbackConfigOrderStopFirst = ServiceSpecRollbackConfigOrder{"stop-first"}
)

// Defines values for ServiceSpecUpdateConfigFailureAction.
var (
	UnknownServiceSpecUpdateConfigFailureAction = ServiceSpecUpdateConfigFailureAction{}

	ServiceSpecUpdateConfigFailureActionContinue = ServiceSpecUpdateConfigFailureAction{"continue"}

	ServiceSpecUpdateConfigFailureActionPause = ServiceSpecUpdateConfigFailureAction{"pause"}

	ServiceSpecUpdateConfigFailureActionRollback = ServiceSpecUpdateConfigFailureAction{"rollback"}
)

// Defines values for ServiceSpecUpdateConfigOrder.
var (
	UnknownServiceSpecUpdateConfigOrder = ServiceSpecUpdateConfigOrder{}

	ServiceSpecUpdateConfigOrderStartFirst = ServiceSpecUpdateConfigOrder{"start-first"}

	ServiceSpecUpdateConfigOrderStopFirst = ServiceSpecUpdateConfigOrder{"stop-first"}
)

// Defines values for ServiceUpdateStatusState.
var (
	UnknownServiceUpdateStatusState = ServiceUpdateStatusState{}

	ServiceUpdateStatusStateCompleted = ServiceUpdateStatusState{"completed"}

	ServiceUpdateStatusStatePaused = ServiceUpdateStatusState{"paused"}

	ServiceUpdateStatusStateUpdating = ServiceUpdateStatusState{"updating"}
)

// Defines values for SwarmSpecCAConfigExternalCAsProtocol.
var (
	UnknownSwarmSpecCAConfigExternalCAsProtocol = SwarmSpecCAConfigExternalCAsProtocol{}

	SwarmSpecCAConfigExternalCAsProtocolCfssl = SwarmSpecCAConfigExternalCAsProtocol{"cfssl"}
)

// Defines values for SystemInfoCgroupDriver.
var (
	UnknownSystemInfoCgroupDriver = SystemInfoCgroupDriver{}

	SystemInfoCgroupDriverCgroupfs = SystemInfoCgroupDriver{"cgroupfs"}

	SystemInfoCgroupDriverNone = SystemInfoCgroupDriver{"none"}

	SystemInfoCgroupDriverSystemd = SystemInfoCgroupDriver{"systemd"}
)

// Defines values for SystemInfoCgroupVersion.
var (
	UnknownSystemInfoCgroupVersion = SystemInfoCgroupVersion{}

	SystemInfoCgroupVersionN1 = SystemInfoCgroupVersion{"1"}

	SystemInfoCgroupVersionN2 = SystemInfoCgroupVersion{"2"}
)

// Defines values for SystemInfoIsolation.
var (
	UnknownSystemInfoIsolation = SystemInfoIsolation{}

	SystemInfoIsolationDefault = SystemInfoIsolation{"default"}

	SystemInfoIsolationHyperv = SystemInfoIsolation{"hyperv"}

	SystemInfoIsolationProcess = SystemInfoIsolation{"process"}
)

// Defines values for TaskSpecRestartPolicyCondition.
var (
	UnknownTaskSpecRestartPolicyCondition = TaskSpecRestartPolicyCondition{}

	TaskSpecRestartPolicyConditionAny = TaskSpecRestartPolicyCondition{"any"}

	TaskSpecRestartPolicyConditionNone = TaskSpecRestartPolicyCondition{"none"}

	TaskSpecRestartPolicyConditionOnFailure = TaskSpecRestartPolicyCondition{"on-failure"}
)

// Defines values for TaskSpecContainerSpecIsolation.
var (
	UnknownTaskSpecContainerSpecIsolation = TaskSpecContainerSpecIsolation{}

	TaskSpecContainerSpecIsolationDefault = TaskSpecContainerSpecIsolation{"default"}

	TaskSpecContainerSpecIsolationHyperv = TaskSpecContainerSpecIsolation{"hyperv"}

	TaskSpecContainerSpecIsolationProcess = TaskSpecContainerSpecIsolation{"process"}
)

// Defines values for VolumeScope.
var (
	UnknownVolumeScope = VolumeScope{}

	VolumeScopeGlobal = VolumeScope{"global"}

	VolumeScopeLocal = VolumeScope{"local"}
)

// Address represents an IPv4 or IPv6 IP address.
type Address struct {
	// IP address.
	Addr *string `json:"Addr,omitempty"`

	// Mask length of the IP address.
	PrefixLen *int `json:"PrefixLen,omitempty"`
}

// AuthConfig defines model for AuthConfig.
type AuthConfig struct {
	Email         *string `json:"email,omitempty"`
	Password      *string `json:"password,omitempty"`
	Serveraddress *string `json:"serveraddress,omitempty"`
	Username      *string `json:"username,omitempty"`
}

// ClusterInfo represents information about the swarm as is returned by the
// "/info" endpoint. Join-tokens are not included.
type ClusterInfo struct {
	// Date and time at which the swarm was initialised in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// DataPathPort specifies the data path port number for data traffic.
	// Acceptable port range is 1024 to 49151.
	// If no port is set or is set to 0, the default port (4789) is used.
	DataPathPort *uint32 `json:"DataPathPort,omitempty"`

	// Default Address Pool specifies default subnet pools for global scope
	// networks.
	DefaultAddrPool []string `json:"DefaultAddrPool,omitempty"`

	// The ID of the swarm.
	ID *string `json:"ID,omitempty"`

	// Whether there is currently a root CA rotation in progress for the swarm
	RootRotationInProgress *bool `json:"RootRotationInProgress,omitempty"`

	// User modifiable swarm configuration.
	Spec *SwarmSpec `json:"Spec,omitempty"`

	// SubnetSize specifies the subnet size of the networks created from the
	// default subnet pool.
	SubnetSize *uint32 `json:"SubnetSize,omitempty"`

	// Information about the issuer of leaf TLS certificates and the trusted root
	// CA certificate.
	TLSInfo *TLSInfo `json:"TLSInfo,omitempty"`

	// Date and time at which the swarm was last updated in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// CodeVersionInfo defines model for CodeVersionInfo.
type CodeVersionInfo struct {
	BuildDate    string `json:"buildDate"`
	Compiler     string `json:"compiler"`
	GitCommit    string `json:"gitCommit"`
	GitTreeState string `json:"gitTreeState"`
	GitVersion   string `json:"gitVersion"`
	GoVersion    string `json:"goVersion"`
	Major        string `json:"major"`
	Minor        string `json:"minor"`
	Platform     string `json:"platform"`
}

// Commit holds the Git-commit (SHA1) that a binary was built from, as
// reported in the version-string of external tools, such as `containerd`,
// or `runC`.
type Commit struct {
	// Commit ID of external tool expected by dockerd as set at build time.
	Expected *string `json:"Expected,omitempty"`

	// Actual commit ID of external tool.
	ID *string `json:"ID,omitempty"`
}

// Config defines model for Config.
type Config struct {
	CreatedAt *string     `json:"CreatedAt,omitempty"`
	ID        *string     `json:"ID,omitempty"`
	Spec      *ConfigSpec `json:"Spec,omitempty"`
	UpdatedAt *string     `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// ConfigSpec defines model for ConfigSpec.
type ConfigSpec struct {
	// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
	// config data.
	Data *string `json:"Data,omitempty"`

	// User-defined key/value metadata.
	Labels *ConfigSpec_Labels `json:"Labels,omitempty"`

	// User-defined name of the config.
	Name *string `json:"Name,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Templating *Driver `json:"Templating,omitempty"`
}

// User-defined key/value metadata.
type ConfigSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Configuration for a container that is portable between hosts.
type ContainerConfig struct {
	// Command is already escaped (Windows only)
	ArgsEscaped *bool `json:"ArgsEscaped,omitempty"`

	// Whether to attach to `stderr`.
	AttachStderr *bool `json:"AttachStderr,omitempty"`

	// Whether to attach to `stdin`.
	AttachStdin *bool `json:"AttachStdin,omitempty"`

	// Whether to attach to `stdout`.
	AttachStdout *bool `json:"AttachStdout,omitempty"`

	// Command to run specified as a string or an array of strings.
	Cmd []string `json:"Cmd,omitempty"`

	// The domain name to use for the container.
	Domainname *string `json:"Domainname,omitempty"`

	// The entry point for the container as a string or an array of strings.
	//
	// If the array consists of exactly one empty string (`[""]`) then the
	// entry point is reset to system default (i.e., the entry point used by
	// docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
	Entrypoint []string `json:"Entrypoint,omitempty"`

	// A list of environment variables to set inside the container in the
	// form `["VAR=value", ...]`. A variable without `=` is removed from the
	// environment, rather than to have an empty value.
	Env []string `json:"Env,omitempty"`

	// An object mapping ports to an empty object in the form:
	//
	// `{"<port>/<tcp|udp|sctp>": {}}`
	ExposedPorts *ContainerConfig_ExposedPorts `json:"ExposedPorts,omitempty"`

	// A test to perform to check that the container is healthy.
	Healthcheck *HealthConfig `json:"Healthcheck,omitempty"`

	// The hostname to use for the container, as a valid RFC 1123 hostname.
	Hostname *string `json:"Hostname,omitempty"`

	// The name (or reference) of the image to use when creating the container,
	// or which was used when the container was created.
	Image *string `json:"Image,omitempty"`

	// User-defined key/value metadata.
	Labels *ContainerConfig_Labels `json:"Labels,omitempty"`

	// MAC address of the container.
	MacAddress *string `json:"MacAddress,omitempty"`

	// Disable networking for the container.
	NetworkDisabled *bool `json:"NetworkDisabled,omitempty"`

	// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
	OnBuild []string `json:"OnBuild,omitempty"`

	// Open `stdin`
	OpenStdin *bool `json:"OpenStdin,omitempty"`

	// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
	Shell []string `json:"Shell,omitempty"`

	// Close `stdin` after one attached client disconnects
	StdinOnce *bool `json:"StdinOnce,omitempty"`

	// Signal to stop a container as a string or unsigned integer.
	StopSignal *string `json:"StopSignal,omitempty"`

	// Timeout to stop a container in seconds.
	StopTimeout *int `json:"StopTimeout,omitempty"`

	// Attach standard streams to a TTY, including `stdin` if it is not closed.
	Tty *bool `json:"Tty,omitempty"`

	// The user that commands are run as inside the container.
	User *string `json:"User,omitempty"`

	// An object mapping mount point paths inside the container to empty
	// objects.
	Volumes *ContainerConfig_Volumes `json:"Volumes,omitempty"`

	// The working directory for commands to run in.
	WorkingDir *string `json:"WorkingDir,omitempty"`
}

// An object mapping ports to an empty object in the form:
//
// `{"<port>/<tcp|udp|sctp>": {}}`
type ContainerConfig_ExposedPorts struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// User-defined key/value metadata.
type ContainerConfig_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// An object mapping mount point paths inside the container to empty
// objects.
type ContainerConfig_Volumes struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ContainerInspectResponse defines model for ContainerInspectResponse.
type ContainerInspectResponse struct {
	AppArmorProfile *string `json:"AppArmorProfile,omitempty"`

	// The arguments to the command being run
	Args []string `json:"Args,omitempty"`

	// Configuration for a container that is portable between hosts.
	Config *ContainerConfig `json:"Config,omitempty"`

	// The time the container was created
	Created *string `json:"Created,omitempty"`
	Driver  *string `json:"Driver,omitempty"`

	// IDs of exec instances that are running in the container.
	ExecIDS []string `json:"ExecIDs,omitempty"`

	// Information about the storage driver used to store the container's and
	// image's filesystem.
	GraphDriver *GraphDriverData `json:"GraphDriver,omitempty"`

	// Container configuration that depends on the host we are running on
	HostConfig   *HostConfig `json:"HostConfig,omitempty"`
	HostnamePath *string     `json:"HostnamePath,omitempty"`
	HostsPath    *string     `json:"HostsPath,omitempty"`

	// The ID of the container
	ID *string `json:"Id,omitempty"`

	// The container's image ID
	Image      *string      `json:"Image,omitempty"`
	LogPath    *string      `json:"LogPath,omitempty"`
	MountLabel *string      `json:"MountLabel,omitempty"`
	Mounts     []MountPoint `json:"Mounts,omitempty"`
	Name       *string      `json:"Name,omitempty"`

	// NetworkSettings exposes the network settings in the API
	NetworkSettings *NetworkSettings `json:"NetworkSettings,omitempty"`

	// The path to the command being run
	Path           *string `json:"Path,omitempty"`
	Platform       *string `json:"Platform,omitempty"`
	ProcessLabel   *string `json:"ProcessLabel,omitempty"`
	ResolvConfPath *string `json:"ResolvConfPath,omitempty"`
	RestartCount   *int    `json:"RestartCount,omitempty"`

	// The total size of all the files in this container.
	SizeRootFs *int64 `json:"SizeRootFs,omitempty"`

	// The size of files that have been created or changed by this
	// container.
	SizeRw *int64 `json:"SizeRw,omitempty"`

	// ContainerState stores container's running state. It's part of ContainerJSONBase
	// and will be returned by the "inspect" command.
	State *ContainerState `json:"State,omitempty"`
}

// ContainerState stores container's running state. It's part of ContainerJSONBase
// and will be returned by the "inspect" command.
type ContainerState struct {
	Dead  *bool   `json:"Dead,omitempty"`
	Error *string `json:"Error,omitempty"`

	// The last exit code of this container
	ExitCode *int `json:"ExitCode,omitempty"`

	// The time when this container last exited.
	FinishedAt *string `json:"FinishedAt,omitempty"`

	// Health stores information about the container's healthcheck results.
	Health *Health `json:"Health,omitempty"`

	// Whether this container has been killed because it ran out of memory.
	OOMKilled *bool `json:"OOMKilled,omitempty"`

	// Whether this container is paused.
	Paused *bool `json:"Paused,omitempty"`

	// The process ID of this container
	Pid *int `json:"Pid,omitempty"`

	// Whether this container is restarting.
	Restarting *bool `json:"Restarting,omitempty"`

	// Whether this container is running.
	//
	// Note that a running container can be _paused_. The `Running` and `Paused`
	// booleans are not mutually exclusive:
	//
	// When pausing a container (on Linux), the freezer cgroup is used to suspend
	// all processes in the container. Freezing the process requires the process to
	// be running. As a result, paused containers are both `Running` _and_ `Paused`.
	//
	// Use the `Status` field instead to determine if a container's state is "running".
	Running *bool `json:"Running,omitempty"`

	// The time when this container was last started.
	StartedAt *string `json:"StartedAt,omitempty"`

	// String representation of the container state. Can be one of "created",
	// "running", "paused", "restarting", "removing", "exited", or "dead".
	Status *ContainerStateStatus `json:"Status,omitempty"`
}

// ContainerSummary defines model for ContainerSummary.
type ContainerSummary struct {
	// Command to run when starting the container
	Command *string `json:"Command,omitempty"`

	// When the container was created
	Created    *int64 `json:"Created,omitempty"`
	HostConfig *struct {
		NetworkMode *string `json:"NetworkMode,omitempty"`
	} `json:"HostConfig,omitempty"`

	// The ID of this container
	ID *string `json:"Id,omitempty"`

	// The name of the image used when creating this container
	Image *string `json:"Image,omitempty"`

	// The ID of the image that this container was created from
	ImageID *string `json:"ImageID,omitempty"`

	// User-defined key/value metadata.
	Labels *ContainerSummary_Labels `json:"Labels,omitempty"`
	Mounts []MountPoint             `json:"Mounts,omitempty"`

	// The names that this container has been given
	Names []string `json:"Names,omitempty"`

	// A summary of the container's network settings
	NetworkSettings *struct {
		Networks *ContainerSummary_NetworkSettings_Networks `json:"Networks,omitempty"`
	} `json:"NetworkSettings,omitempty"`

	// The ports exposed by this container
	Ports []Port `json:"Ports,omitempty"`

	// The total size of all the files in this container
	SizeRootFs *int64 `json:"SizeRootFs,omitempty"`

	// The size of files that have been created or changed by this container
	SizeRw *int64 `json:"SizeRw,omitempty"`

	// The state of this container (e.g. `Exited`)
	State *string `json:"State,omitempty"`

	// Additional human-readable status of this container (e.g. `Exit 0`)
	Status *string `json:"Status,omitempty"`
}

// User-defined key/value metadata.
type ContainerSummary_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ContainerSummary_NetworkSettings_Networks defines model for ContainerSummary.NetworkSettings.Networks.
type ContainerSummary_NetworkSettings_Networks struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// A device mapping between the host and container
type DeviceMapping struct {
	CgroupPermissions *string `json:"CgroupPermissions,omitempty"`
	PathInContainer   *string `json:"PathInContainer,omitempty"`
	PathOnHost        *string `json:"PathOnHost,omitempty"`
}

// A request for devices to be sent to device drivers
type DeviceRequest struct {
	// A list of capabilities; an OR list of AND lists of capabilities.
	Capabilities [][]string `json:"Capabilities,omitempty"`
	Count        *int       `json:"Count,omitempty"`
	DeviceIDS    []string   `json:"DeviceIDs,omitempty"`
	Driver       *string    `json:"Driver,omitempty"`

	// Driver-specific options, specified as a key/value pairs. These options
	// are passed directly to the driver.
	Options *DeviceRequest_Options `json:"Options,omitempty"`
}

// Driver-specific options, specified as a key/value pairs. These options
// are passed directly to the driver.
type DeviceRequest_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Driver represents a driver (network, logging, secrets).
type Driver struct {
	// Name of the driver.
	Name string `json:"Name"`

	// Key/value map of driver-specific options.
	Options *Driver_Options `json:"Options,omitempty"`
}

// Key/value map of driver-specific options.
type Driver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// EndpointIPAMConfig represents an endpoint's IPAM configuration.
type EndpointIPAMConfig struct {
	IPV4address  *string  `json:"IPv4Address,omitempty"`
	IPV6address  *string  `json:"IPv6Address,omitempty"`
	LinkLocalIPS []string `json:"LinkLocalIPs,omitempty"`
}

// EndpointPortConfig defines model for EndpointPortConfig.
type EndpointPortConfig struct {
	Name     *string                     `json:"Name,omitempty"`
	Protocol *EndpointPortConfigProtocol `json:"Protocol,omitempty"`

	// The mode in which port is published.
	//
	// <p><br /></p>
	//
	// - "ingress" makes the target port accessible on every node,
	//   regardless of whether there is a task for the service running on
	//   that node or not.
	// - "host" bypasses the routing mesh and publish the port directly on
	//   the swarm node where that service is running.
	PublishMode *EndpointPortConfigPublishMode `json:"PublishMode,omitempty"`

	// The port on the swarm hosts.
	PublishedPort *int `json:"PublishedPort,omitempty"`

	// The port inside the container.
	TargetPort *int `json:"TargetPort,omitempty"`
}

// Configuration for a network endpoint.
type EndpointSettings struct {
	Aliases []string `json:"Aliases,omitempty"`

	// DriverOpts is a mapping of driver options and values. These options
	// are passed directly to the driver and are driver specific.
	DriverOpts *EndpointSettings_DriverOpts `json:"DriverOpts,omitempty"`

	// Unique ID for the service endpoint in a Sandbox.
	EndpointID *string `json:"EndpointID,omitempty"`

	// Gateway address for this network.
	Gateway *string `json:"Gateway,omitempty"`

	// Global IPv6 address.
	GlobalIPV6address *string `json:"GlobalIPv6Address,omitempty"`

	// Mask length of the global IPv6 address.
	GlobalIPV6prefixLen *int64 `json:"GlobalIPv6PrefixLen,omitempty"`

	// EndpointIPAMConfig represents an endpoint's IPAM configuration.
	IPAMConfig *EndpointIPAMConfig `json:"IPAMConfig,omitempty"`

	// IPv4 address.
	IPAddress *string `json:"IPAddress,omitempty"`

	// Mask length of the IPv4 address.
	IPPrefixLen *int `json:"IPPrefixLen,omitempty"`

	// IPv6 gateway address.
	IPV6gateway *string  `json:"IPv6Gateway,omitempty"`
	Links       []string `json:"Links,omitempty"`

	// MAC address for the endpoint on this network.
	MacAddress *string `json:"MacAddress,omitempty"`

	// Unique ID of the network.
	NetworkID *string `json:"NetworkID,omitempty"`
}

// DriverOpts is a mapping of driver options and values. These options
// are passed directly to the driver and are driver specific.
type EndpointSettings_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Properties that can be configured to access and load balance a service.
type EndpointSpec struct {
	// The mode of resolution to use for internal load balancing between tasks.
	Mode *EndpointSpecMode `json:"Mode,omitempty"`

	// List of exposed ports that this service is accessible on from the
	// outside. Ports can only be provided if `vip` resolution mode is used.
	Ports []EndpointPortConfig `json:"Ports,omitempty"`
}

// EngineDescription provides information about an engine.
type EngineDescription struct {
	EngineVersion *string                   `json:"EngineVersion,omitempty"`
	Labels        *EngineDescription_Labels `json:"Labels,omitempty"`
	Plugins       []struct {
		Name *string `json:"Name,omitempty"`
		Type *string `json:"Type,omitempty"`
	} `json:"Plugins,omitempty"`
}

// EngineDescription_Labels defines model for EngineDescription.Labels.
type EngineDescription_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Represents an error.
type ErrorResponse struct {
	// The error message.
	Message string `json:"message"`
}

// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
// String resources (e.g, `GPU=UUID1`).
type GenericResources []struct {
	DiscreteResourceSpec *struct {
		Kind  *string `json:"Kind,omitempty"`
		Value *int64  `json:"Value,omitempty"`
	} `json:"DiscreteResourceSpec,omitempty"`
	NamedResourceSpec *struct {
		Kind  *string `json:"Kind,omitempty"`
		Value *string `json:"Value,omitempty"`
	} `json:"NamedResourceSpec,omitempty"`
}

// Information about the storage driver used to store the container's and
// image's filesystem.
type GraphDriverData struct {
	// Low-level storage metadata, provided as key/value pairs.
	//
	// This information is driver-specific, and depends on the storage-driver
	// in use, and should be used for informational purposes only.
	Data GraphDriverData_Data `json:"Data"`

	// Name of the storage driver.
	Name string `json:"Name"`
}

// Low-level storage metadata, provided as key/value pairs.
//
// This information is driver-specific, and depends on the storage-driver
// in use, and should be used for informational purposes only.
type GraphDriverData_Data struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Health stores information about the container's healthcheck results.
type Health struct {
	// FailingStreak is the number of consecutive failures
	FailingStreak *int `json:"FailingStreak,omitempty"`

	// Log contains the last few results (oldest first)
	Log []HealthcheckResult `json:"Log,omitempty"`

	// Status is one of `none`, `starting`, `healthy` or `unhealthy`
	//
	// - "none"      Indicates there is no healthcheck
	// - "starting"  Starting indicates that the container is not yet ready
	// - "healthy"   Healthy indicates that the container is running correctly
	// - "unhealthy" Unhealthy indicates that the container has a problem
	Status *HealthStatus `json:"Status,omitempty"`
}

// A test to perform to check that the container is healthy.
type HealthConfig struct {
	// The time to wait between checks in nanoseconds. It should be 0 or at
	// least 1000000 (1 ms). 0 means inherit.
	Interval *int `json:"Interval,omitempty"`

	// The number of consecutive failures needed to consider a container as
	// unhealthy. 0 means inherit.
	Retries *int `json:"Retries,omitempty"`

	// Start period for the container to initialize before starting
	// health-retries countdown in nanoseconds. It should be 0 or at least
	// 1000000 (1 ms). 0 means inherit.
	StartPeriod *int `json:"StartPeriod,omitempty"`

	// The test to perform. Possible values are:
	//
	// - `[]` inherit healthcheck from image or parent image
	// - `["NONE"]` disable healthcheck
	// - `["CMD", args...]` exec arguments directly
	// - `["CMD-SHELL", command]` run command with system's default shell
	Test []string `json:"Test,omitempty"`

	// The time to wait before considering the check to have hung. It should
	// be 0 or at least 1000000 (1 ms). 0 means inherit.
	Timeout *int `json:"Timeout,omitempty"`
}

// HealthcheckResult stores information about a single run of a healthcheck probe
type HealthcheckResult struct {
	// Date and time at which this check ended in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	End *string `json:"End,omitempty"`

	// ExitCode meanings:
	//
	// - `0` healthy
	// - `1` unhealthy
	// - `2` reserved (considered unhealthy)
	// - other values: error running probe
	ExitCode *int `json:"ExitCode,omitempty"`

	// Output from last check
	Output *string `json:"Output,omitempty"`

	// Date and time at which this check started in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	Start *time.Time `json:"Start,omitempty"`
}

// HostConfig defines model for HostConfig.
type HostConfig struct {
	// Embedded struct due to allOf(#/components/schemas/Resources)
	Resources `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Automatically remove the container when the container's process
	// exits. This has no effect if `RestartPolicy` is set.
	AutoRemove *bool `json:"AutoRemove,omitempty"`

	// A list of volume bindings for this container. Each volume binding
	// is a string in one of these forms:
	//
	// - `host-src:container-dest[:options]` to bind-mount a host path
	//   into the container. Both `host-src`, and `container-dest` must
	//   be an _absolute_ path.
	// - `volume-name:container-dest[:options]` to bind-mount a volume
	//   managed by a volume driver into the container. `container-dest`
	//   must be an _absolute_ path.
	//
	// `options` is an optional, comma-delimited list of:
	//
	// - `nocopy` disables automatic copying of data from the container
	//   path to the volume. The `nocopy` flag only applies to named volumes.
	// - `[ro|rw]` mounts a volume read-only or read-write, respectively.
	//   If omitted or set to `rw`, volumes are mounted read-write.
	// - `[z|Z]` applies SELinux labels to allow or deny multiple containers
	//   to read and write to the same volume.
	//     - `z`: a _shared_ content label is applied to the content. This
	//       label indicates that multiple containers can share the volume
	//       content, for both reading and writing.
	//     - `Z`: a _private unshared_ label is applied to the content.
	//       This label indicates that only the current container can use
	//       a private volume. Labeling systems such as SELinux require
	//       proper labels to be placed on volume content that is mounted
	//       into a container. Without a label, the security system can
	//       prevent a container's processes from using the content. By
	//       default, the labels set by the host operating system are not
	//       modified.
	// - `[[r]shared|[r]slave|[r]private]` specifies mount
	//   [propagation behavior](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).
	//   This only applies to bind-mounted volumes, not internal volumes
	//   or named volumes. Mount propagation requires the source mount
	//   point (the location where the source directory is mounted in the
	//   host operating system) to have the correct propagation properties.
	//   For shared volumes, the source mount point must be set to `shared`.
	//   For slave volumes, the mount must be set to either `shared` or
	//   `slave`.
	Binds []string `json:"Binds,omitempty"`

	// A list of kernel capabilities to add to the container. Conflicts
	// with option 'Capabilities'.
	CapAdd []string `json:"CapAdd,omitempty"`

	// A list of kernel capabilities to drop from the container. Conflicts
	// with option 'Capabilities'.
	CapDrop []string `json:"CapDrop,omitempty"`

	// Cgroup to use for the container.
	Cgroup *string `json:"Cgroup,omitempty"`

	// cgroup namespace mode for the container. Possible values are:
	//
	// - `"private"`: the container runs in its own private cgroup namespace
	// - `"host"`: use the host system's cgroup namespace
	//
	// If not specified, the daemon default is used, which can either be `"private"`
	// or `"host"`, depending on daemon version, kernel support and configuration.
	CgroupnsMode *HostConfigCgroupnsMode `json:"CgroupnsMode,omitempty"`

	// Initial console size, as an `[height, width]` array. (Windows only)
	ConsoleSize []int `json:"ConsoleSize,omitempty"`

	// Path to a file where the container ID is written
	ContainerIDFile *string `json:"ContainerIDFile,omitempty"`

	// A list of DNS servers for the container to use.
	DNS []string `json:"Dns,omitempty"`

	// A list of DNS options.
	DNSOptions []string `json:"DnsOptions,omitempty"`

	// A list of DNS search domains.
	DNSSearch []string `json:"DnsSearch,omitempty"`

	// A list of hostnames/IP mappings to add to the container's `/etc/hosts`
	// file. Specified in the form `["hostname:IP"]`.
	ExtraHosts []string `json:"ExtraHosts,omitempty"`

	// A list of additional groups that the container process will run as.
	GroupAdd []string `json:"GroupAdd,omitempty"`

	// IPC sharing mode for the container. Possible values are:
	//
	// - `"none"`: own private IPC namespace, with /dev/shm not mounted
	// - `"private"`: own private IPC namespace
	// - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
	// - `"container:<name|id>"`: join another (shareable) container's IPC namespace
	// - `"host"`: use the host system's IPC namespace
	//
	// If not specified, daemon default is used, which can either be `"private"`
	// or `"shareable"`, depending on daemon version and configuration.
	IpcMode *string `json:"IpcMode,omitempty"`

	// Isolation technology of the container. (Windows only)
	Isolation *HostConfigIsolation `json:"Isolation,omitempty"`

	// A list of links for the container in the form `container_name:alias`.
	Links []string `json:"Links,omitempty"`

	// The logging configuration for this container
	LogConfig *struct {
		Config *HostConfig_LogConfig_Config `json:"Config,omitempty"`
		Type   *HostConfigLogConfigType     `json:"Type,omitempty"`
	} `json:"LogConfig,omitempty"`

	// The list of paths to be masked inside the container (this overrides
	// the default set of paths).
	MaskedPaths []string `json:"MaskedPaths,omitempty"`

	// Specification for mounts to be added to the container.
	Mounts []Mount `json:"Mounts,omitempty"`

	// Network mode to use for this container. Supported standard values
	// are: `bridge`, `host`, `none`, and `container:<name|id>`. Any
	// other value is taken as a custom network's name to which this
	// container should connect to.
	NetworkMode *string `json:"NetworkMode,omitempty"`

	// An integer value containing the score given to the container in
	// order to tune OOM killer preferences.
	OomScoreAdj *int `json:"OomScoreAdj,omitempty"`

	// Set the PID (Process) Namespace mode for the container. It can be
	// either:
	//
	// - `"container:<name|id>"`: joins another container's PID namespace
	// - `"host"`: use the host's PID namespace inside the container
	PidMode *string `json:"PidMode,omitempty"`

	// PortMap describes the mapping of container ports to host ports, using the
	// container's port-number and protocol as key in the format `<port>/<protocol>`,
	// for example, `80/udp`.
	//
	// If a container's port is mapped for multiple protocols, separate entries
	// are added to the mapping table.
	PortBindings *PortMap `json:"PortBindings,omitempty"`

	// Gives the container full access to the host.
	Privileged *bool `json:"Privileged,omitempty"`

	// Allocates an ephemeral host port for all of a container's
	// exposed ports.
	//
	// Ports are de-allocated when the container stops and allocated when
	// the container starts. The allocated port might be changed when
	// restarting the container.
	//
	// The port is selected from the ephemeral port range that depends on
	// the kernel. For example, on Linux the range is defined by
	// `/proc/sys/net/ipv4/ip_local_port_range`.
	PublishAllPorts *bool `json:"PublishAllPorts,omitempty"`

	// The list of paths to be set as read-only inside the container
	// (this overrides the default set of paths).
	ReadonlyPaths []string `json:"ReadonlyPaths,omitempty"`

	// Mount the container's root filesystem as read only.
	ReadonlyRootfs *bool `json:"ReadonlyRootfs,omitempty"`

	// The behavior to apply when the container exits. The default is not to
	// restart.
	//
	// An ever increasing delay (double the previous delay, starting at 100ms) is
	// added before each restart to prevent flooding the server.
	RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

	// Runtime to use with this container.
	Runtime *string `json:"Runtime,omitempty"`

	// A list of string values to customize labels for MLS systems, such
	// as SELinux.
	SecurityOpt []string `json:"SecurityOpt,omitempty"`

	// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
	ShmSize *int `json:"ShmSize,omitempty"`

	// Storage driver options for this container, in the form `{"size": "120G"}`.
	StorageOpt *HostConfig_StorageOpt `json:"StorageOpt,omitempty"`

	// A list of kernel parameters (sysctls) to set in the container.
	// For example:
	//
	// ```
	// {"net.ipv4.ip_forward": "1"}
	// ```
	Sysctls *HostConfig_Sysctls `json:"Sysctls,omitempty"`

	// A map of container directories which should be replaced by tmpfs
	// mounts, and their corresponding mount options. For example:
	//
	// ```
	// { "/run": "rw,noexec,nosuid,size=65536k" }
	// ```
	Tmpfs *HostConfig_Tmpfs `json:"Tmpfs,omitempty"`

	// UTS namespace to use for the container.
	UTSMode *string `json:"UTSMode,omitempty"`

	// Sets the usernamespace mode for the container when usernamespace
	// remapping option is enabled.
	UsernsMode *string `json:"UsernsMode,omitempty"`

	// Driver that this container uses to mount volumes.
	VolumeDriver *string `json:"VolumeDriver,omitempty"`

	// A list of volumes to inherit from another container, specified in
	// the form `<container name>[:<ro|rw>]`.
	VolumesFrom []string `json:"VolumesFrom,omitempty"`
}

// HostConfig_LogConfig_Config defines model for HostConfig.LogConfig.Config.
type HostConfig_LogConfig_Config struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Storage driver options for this container, in the form `{"size": "120G"}`.
type HostConfig_StorageOpt struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A list of kernel parameters (sysctls) to set in the container.
// For example:
//
// ```
// {"net.ipv4.ip_forward": "1"}
// ```
type HostConfig_Sysctls struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A map of container directories which should be replaced by tmpfs
// mounts, and their corresponding mount options. For example:
//
// ```
// { "/run": "rw,noexec,nosuid,size=65536k" }
// ```
type HostConfig_Tmpfs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// IPAM defines model for IPAM.
type IPAM struct {
	// List of IPAM configuration options, specified as a map:
	//
	// ```
	// {"Subnet": <CIDR>, "IPRange": <CIDR>, "Gateway": <IP address>, "AuxAddress": <device_name:IP address>}
	// ```
	Config []IPAMConfig `json:"Config,omitempty"`

	// Name of the IPAM driver to use.
	Driver *string `json:"Driver,omitempty"`

	// Driver-specific options, specified as a map.
	Options *IPAM_Options `json:"Options,omitempty"`
}

// Driver-specific options, specified as a map.
type IPAM_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// IPAMConfig defines model for IPAMConfig.
type IPAMConfig struct {
	AuxiliaryAddresses *IPAMConfig_AuxiliaryAddresses `json:"AuxiliaryAddresses,omitempty"`
	Gateway            *string                        `json:"Gateway,omitempty"`
	IPRange            *string                        `json:"IPRange,omitempty"`
	Subnet             *string                        `json:"Subnet,omitempty"`
}

// IPAMConfig_AuxiliaryAddresses defines model for IPAMConfig.AuxiliaryAddresses.
type IPAMConfig_AuxiliaryAddresses struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Response to an API call that returns just an Id
type IDResponse struct {
	// The id of the newly created object.
	ID string `json:"Id"`
}

// Information about an image in the local image cache.
type ImageInspect struct {
	// Hardware CPU architecture that the image runs on.
	Architecture *string `json:"Architecture,omitempty"`

	// Name of the author that was specified when committing the image, or as
	// specified through MAINTAINER (deprecated) in the Dockerfile.
	Author *string `json:"Author,omitempty"`

	// Optional message that was set when committing or importing the image.
	Comment *string `json:"Comment,omitempty"`

	// Configuration for a container that is portable between hosts.
	Config *ContainerConfig `json:"Config,omitempty"`

	// The ID of the container that was used to create the image.
	//
	// Depending on how the image was created, this field may be empty.
	Container *string `json:"Container,omitempty"`

	// Configuration for a container that is portable between hosts.
	ContainerConfig *ContainerConfig `json:"ContainerConfig,omitempty"`

	// Date and time at which the image was created, formatted in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	Created *string `json:"Created,omitempty"`

	// The version of Docker that was used to build the image.
	//
	// Depending on how the image was created, this field may be empty.
	DockerVersion *string `json:"DockerVersion,omitempty"`

	// Information about the storage driver used to store the container's and
	// image's filesystem.
	GraphDriver *GraphDriverData `json:"GraphDriver,omitempty"`

	// ID is the content-addressable ID of an image.
	//
	// This identified is a content-addressable digest calculated from the
	// image's configuration (which includes the digests of layers used by
	// the image).
	//
	// Note that this digest differs from the `RepoDigests` below, which
	// holds digests of image manifests that reference the image.
	ID *string `json:"Id,omitempty"`

	// Additional metadata of the image in the local cache. This information
	// is local to the daemon, and not part of the image itself.
	Metadata *struct {
		// Date and time at which the image was last tagged in
		// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
		//
		// This information is only available if the image was tagged locally,
		// and omitted otherwise.
		LastTagTime *string `json:"LastTagTime,omitempty"`
	} `json:"Metadata,omitempty"`

	// Operating System the image is built to run on.
	Os *string `json:"Os,omitempty"`

	// Operating System version the image is built to run on (especially
	// for Windows).
	OsVersion *string `json:"OsVersion,omitempty"`

	// ID of the parent image.
	//
	// Depending on how the image was created, this field may be empty and
	// is only set for images that were built/created locally. This field
	// is empty if the image was pulled from an image registry.
	Parent *string `json:"Parent,omitempty"`

	// List of content-addressable digests of locally available image manifests
	// that the image is referenced from. Multiple manifests can refer to the
	// same image.
	//
	// These digests are usually only available if the image was either pulled
	// from a registry, or if the image was pushed to a registry, which is when
	// the manifest is generated and its digest calculated.
	RepoDigests []string `json:"RepoDigests,omitempty"`

	// List of image names/tags in the local image cache that reference this
	// image.
	//
	// Multiple image tags can refer to the same imagem and this list may be
	// empty if no tags reference the image, in which case the image is
	// "untagged", in which case it can still be referenced by its ID.
	RepoTags []string `json:"RepoTags,omitempty"`

	// Information about the image's RootFS, including the layer IDs.
	RootFS *struct {
		Layers []string `json:"Layers,omitempty"`
		Type   string   `json:"Type"`
	} `json:"RootFS,omitempty"`

	// Total size of the image including all layers it is composed of.
	Size *int64 `json:"Size,omitempty"`

	// CPU architecture variant (presently ARM-only).
	Variant *string `json:"Variant,omitempty"`

	// Total size of the image including all layers it is composed of.
	//
	// In versions of Docker before v1.10, this field was calculated from
	// the image itself and all of its parent images. Docker v1.10 and up
	// store images self-contained, and no longer use a parent-chain, making
	// this field an equivalent of the Size field.
	//
	// This field is kept for backward compatibility, but may be removed in
	// a future version of the API.
	VirtualSize *int64 `json:"VirtualSize,omitempty"`
}

// ImageSummary defines model for ImageSummary.
type ImageSummary struct {
	Containers  int                 `json:"Containers"`
	Created     int                 `json:"Created"`
	ID          string              `json:"Id"`
	Labels      ImageSummary_Labels `json:"Labels"`
	ParentID    string              `json:"ParentId"`
	RepoDigests []string            `json:"RepoDigests"`
	RepoTags    []string            `json:"RepoTags"`
	SharedSize  int                 `json:"SharedSize"`
	Size        int                 `json:"Size"`
	VirtualSize int                 `json:"VirtualSize"`
}

// ImageSummary_Labels defines model for ImageSummary.Labels.
type ImageSummary_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Index defines model for Index.
type Index struct {
	Paths []string `json:"paths"`
}

// IndexInfo contains information about a registry.
type IndexInfo struct {
	// List of mirrors, expressed as URIs.
	Mirrors []string `json:"Mirrors,omitempty"`

	// Name of the registry, such as "docker.io".
	Name *string `json:"Name,omitempty"`

	// Indicates whether this is an official registry (i.e., Docker Hub / docker.io)
	Official *bool `json:"Official,omitempty"`

	// Indicates if the registry is part of the list of insecure
	// registries.
	//
	// If `false`, the registry is insecure. Insecure registries accept
	// un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from
	// unknown CAs) communication.
	//
	// > **Warning**: Insecure registries can be useful when running a local
	// > registry. However, because its use creates security vulnerabilities
	// > it should ONLY be enabled for testing purposes. For increased
	// > security, users should add their CA to their system's list of
	// > trusted CAs instead of enabling this option.
	Secure *bool `json:"Secure,omitempty"`
}

// KraudCertificateGenerateResponse defines model for Kraud.CertificateGenerateResponse.
type KraudCertificateGenerateResponse struct {
	Ca   string `json:"ca"`
	Cert string `json:"cert"`
	Key  string `json:"key"`
}

// KraudCreateImageResponse defines model for Kraud.CreateImageResponse.
type KraudCreateImageResponse struct {
	// Image is a named docker image
	Created *KraudImageName  `json:"created,omitempty"`
	Renamed []KraudImageName `json:"renamed,omitempty"`
}

// Image is a docker image for a specific architecture
type KraudImage struct {
	Config map[string]interface{} `json:"Config"`
	ID     string                 `json:"ID"`
	Layers []KraudLayerReference  `json:"Layers"`
	OciID  string                 `json:"OciID"`
	Size   uint64                 `json:"Size"`
}

// Image is a named docker image
type KraudImageName struct {
	AID string `json:"AID"`

	// Image is a docker image for a specific architecture
	Amd64 *KraudImage `json:"Amd64,omitempty"`
	ID    string      `json:"ID"`
	Ref   string      `json:"Ref"`
}

// KraudImageNameList defines model for Kraud.ImageNameList.
type KraudImageNameList struct {
	Items []KraudImageName `json:"items"`
}

// Layer is a docker image layer
type KraudLayer struct {
	ID       string `json:"ID"`
	OciID    string `json:"OciID"`
	Refcount int    `json:"refcount"`
	Sha256   string `json:"sha256"`
	Size     uint64 `json:"size"`
}

// KraudLayerList defines model for Kraud.LayerList.
type KraudLayerList struct {
	Items []KraudLayer `json:"items"`
}

// KraudLayerReference defines model for Kraud.LayerReference.
type KraudLayerReference struct {
	ID    *string `json:"ID,omitempty"`
	OciID *string `json:"OciID,omitempty"`
}

// KraudTenantInfo defines model for Kraud.TenantInfo.
type KraudTenantInfo struct {
	ID  string `json:"id"`
	Org string `json:"org"`
}

// An object describing a limit on resources which can be requested by a task.
type Limit struct {
	MemoryBytes *int64 `json:"MemoryBytes,omitempty"`
	NanoCPUS    *int64 `json:"NanoCPUs,omitempty"`

	// Limits the maximum number of PIDs in the container. Set `0` for unlimited.
	Pids *int64 `json:"Pids,omitempty"`
}

// ManagerStatus represents the status of a manager.
//
// It provides the current status of a node's manager component, if the node
// is a manager.
type ManagerStatus struct {
	// The IP address and port at which the manager is reachable.
	Addr   *string `json:"Addr,omitempty"`
	Leader *bool   `json:"Leader,omitempty"`

	// Reachability represents the reachability of a node.
	Reachability *Reachability `json:"Reachability,omitempty"`
}

// Mount defines model for Mount.
type Mount struct {
	// Optional configuration for the `bind` type.
	BindOptions *struct {
		// Disable recursive bind mount.
		NonRecursive *bool `json:"NonRecursive,omitempty"`

		// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
		Propagation *MountBindOptionsPropagation `json:"Propagation,omitempty"`
	} `json:"BindOptions,omitempty"`

	// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
	Consistency *string `json:"Consistency,omitempty"`

	// Whether the mount should be read-only.
	ReadOnly *bool `json:"ReadOnly,omitempty"`

	// Mount source (e.g. a volume name, a host path).
	Source *string `json:"Source,omitempty"`

	// Container path.
	Target *string `json:"Target,omitempty"`

	// Optional configuration for the `tmpfs` type.
	TmpfsOptions *struct {
		// The permission mode for the tmpfs mount in an integer.
		Mode *int `json:"Mode,omitempty"`

		// The size for the tmpfs mount in bytes.
		SizeBytes *int64 `json:"SizeBytes,omitempty"`
	} `json:"TmpfsOptions,omitempty"`

	// The mount type. Available types:
	//
	// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
	// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
	// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
	// - `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
	Type *MountType `json:"Type,omitempty"`

	// Optional configuration for the `volume` type.
	VolumeOptions *struct {
		// Map of driver specific options
		DriverConfig *struct {
			// Name of the driver to use to create the volume.
			Name *string `json:"Name,omitempty"`

			// key/value map of driver specific options.
			Options *Mount_VolumeOptions_DriverConfig_Options `json:"Options,omitempty"`
		} `json:"DriverConfig,omitempty"`

		// User-defined key/value metadata.
		Labels *Mount_VolumeOptions_Labels `json:"Labels,omitempty"`

		// Populate volume with data from the target.
		NoCopy *bool `json:"NoCopy,omitempty"`
	} `json:"VolumeOptions,omitempty"`
}

// key/value map of driver specific options.
type Mount_VolumeOptions_DriverConfig_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// User-defined key/value metadata.
type Mount_VolumeOptions_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// MountPoint represents a mount point configuration inside the container.
// This is used for reporting the mountpoints in use by a container.
type MountPoint struct {
	// Destination is the path relative to the container root (`/`) where
	// the `Source` is mounted inside the container.
	Destination *string `json:"Destination,omitempty"`

	// Driver is the volume driver used to create the volume (if it is a volume).
	Driver *string `json:"Driver,omitempty"`

	// Mode is a comma separated list of options supplied by the user when
	// creating the bind/volume mount.
	//
	// The default is platform-specific (`"z"` on Linux, empty on Windows).
	Mode *string `json:"Mode,omitempty"`

	// Name is the name reference to the underlying data defined by `Source`
	// e.g., the volume name.
	Name *string `json:"Name,omitempty"`

	// Propagation describes how mounts are propagated from the host into the
	// mount point, and vice-versa. Refer to the [Linux kernel documentation](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)
	// for details. This field is not used on Windows.
	Propagation *string `json:"Propagation,omitempty"`

	// Whether the mount is mounted writable (read-write).
	RW *bool `json:"RW,omitempty"`

	// Source location of the mount.
	//
	// For volumes, this contains the storage location of the volume (within
	// `/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains
	// the source (host) part of the bind-mount. For `tmpfs` mount points, this
	// field is empty.
	Source *string `json:"Source,omitempty"`

	// The mount type:
	//
	// - `bind` a mount of a file or directory from the host into the container.
	// - `volume` a docker volume with the given `Name`.
	// - `tmpfs` a `tmpfs`.
	// - `npipe` a named pipe from the host into the container.
	Type *MountPointType `json:"Type,omitempty"`
}

// Network defines model for Network.
type Network struct {
	Attachable *bool               `json:"Attachable,omitempty"`
	Containers *Network_Containers `json:"Containers,omitempty"`
	Created    *string             `json:"Created,omitempty"`
	Driver     *string             `json:"Driver,omitempty"`
	EnableIPV6 *bool               `json:"EnableIPv6,omitempty"`
	IPAM       *IPAM               `json:"IPAM,omitempty"`
	ID         *string             `json:"Id,omitempty"`
	Ingress    *bool               `json:"Ingress,omitempty"`
	Internal   *bool               `json:"Internal,omitempty"`
	Labels     *Network_Labels     `json:"Labels,omitempty"`
	Name       *string             `json:"Name,omitempty"`
	Options    *Network_Options    `json:"Options,omitempty"`
	Scope      *string             `json:"Scope,omitempty"`
}

// Network_Containers defines model for Network.Containers.
type Network_Containers struct {
	AdditionalProperties map[string]NetworkContainer `json:"-"`
}

// Network_Labels defines model for Network.Labels.
type Network_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Network_Options defines model for Network.Options.
type Network_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Specifies how a service should be attached to a particular network.
type NetworkAttachmentConfig struct {
	// Discoverable alternate names for the service on this network.
	Aliases []string `json:"Aliases,omitempty"`

	// Driver attachment options for the network target.
	DriverOpts *NetworkAttachmentConfig_DriverOpts `json:"DriverOpts,omitempty"`

	// The target network for attachment. Must be a network name or ID.
	Target *string `json:"Target,omitempty"`
}

// Driver attachment options for the network target.
type NetworkAttachmentConfig_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// NetworkContainer defines model for NetworkContainer.
type NetworkContainer struct {
	EndpointID  *string `json:"EndpointID,omitempty"`
	IPV4address *string `json:"IPv4Address,omitempty"`
	IPV6address *string `json:"IPv6Address,omitempty"`
	MacAddress  *string `json:"MacAddress,omitempty"`
	Name        *string `json:"Name,omitempty"`
}

// NetworkSettings exposes the network settings in the API
type NetworkSettings struct {
	// Name of the network'a bridge (for example, `docker0`).
	Bridge *string `json:"Bridge,omitempty"`

	// EndpointID uniquely represents a service endpoint in a Sandbox.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	EndpointID *string `json:"EndpointID,omitempty"`

	// Gateway address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	Gateway *string `json:"Gateway,omitempty"`

	// Global IPv6 address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	GlobalIPV6address *string `json:"GlobalIPv6Address,omitempty"`

	// Mask length of the global IPv6 address.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	GlobalIPV6prefixLen *int `json:"GlobalIPv6PrefixLen,omitempty"`

	// Indicates if hairpin NAT should be enabled on the virtual interface.
	HairpinMode *bool `json:"HairpinMode,omitempty"`

	// IPv4 address for the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPAddress *string `json:"IPAddress,omitempty"`

	// Mask length of the IPv4 address.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPPrefixLen *int `json:"IPPrefixLen,omitempty"`

	// IPv6 gateway address for this network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	IPV6gateway *string `json:"IPv6Gateway,omitempty"`

	// IPv6 unicast address using the link-local prefix.
	LinkLocalIPV6address *string `json:"LinkLocalIPv6Address,omitempty"`

	// Prefix length of the IPv6 unicast address.
	LinkLocalIPV6prefixLen *int `json:"LinkLocalIPv6PrefixLen,omitempty"`

	// MAC address for the container on the default "bridge" network.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when attached to the
	// > default "bridge" network. Use the information from the "bridge"
	// > network inside the `Networks` map instead, which contains the same
	// > information. This field was deprecated in Docker 1.9 and is scheduled
	// > to be removed in Docker 17.12.0
	MacAddress *string `json:"MacAddress,omitempty"`

	// Information about all networks that the container is connected to.
	Networks *NetworkSettings_Networks `json:"Networks,omitempty"`

	// PortMap describes the mapping of container ports to host ports, using the
	// container's port-number and protocol as key in the format `<port>/<protocol>`,
	// for example, `80/udp`.
	//
	// If a container's port is mapped for multiple protocols, separate entries
	// are added to the mapping table.
	Ports *PortMap `json:"Ports,omitempty"`

	// SandboxID uniquely represents a container's network stack.
	SandboxID *string `json:"SandboxID,omitempty"`

	// SandboxKey identifies the sandbox
	SandboxKey             *string   `json:"SandboxKey,omitempty"`
	SecondaryIPAddresses   []Address `json:"SecondaryIPAddresses,omitempty"`
	SecondaryIPV6addresses []Address `json:"SecondaryIPv6Addresses,omitempty"`
}

// Information about all networks that the container is connected to.
type NetworkSettings_Networks struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// NetworkingConfig represents the container's networking configuration for
// each of its interfaces.
// It is used for the networking configs specified in the `docker create`
// and `docker network connect` commands.
type NetworkingConfig struct {
	// A mapping of network name to endpoint configuration for that network.
	EndpointsConfig *NetworkingConfig_EndpointsConfig `json:"EndpointsConfig,omitempty"`
}

// A mapping of network name to endpoint configuration for that network.
type NetworkingConfig_EndpointsConfig struct {
	AdditionalProperties map[string]EndpointSettings `json:"-"`
}

// Node defines model for Node.
type Node struct {
	// Date and time at which the node was added to the swarm in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// NodeDescription encapsulates the properties of the Node as reported by the
	// agent.
	Description *NodeDescription `json:"Description,omitempty"`
	ID          *string          `json:"ID,omitempty"`

	// ManagerStatus represents the status of a manager.
	//
	// It provides the current status of a node's manager component, if the node
	// is a manager.
	ManagerStatus *ManagerStatus `json:"ManagerStatus,omitempty"`
	Spec          *NodeSpec      `json:"Spec,omitempty"`

	// NodeStatus represents the status of a node.
	//
	// It provides the current status of the node, as seen by the manager.
	Status *NodeStatus `json:"Status,omitempty"`

	// Date and time at which the node was last updated in
	// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
	UpdatedAt *string `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// NodeDescription encapsulates the properties of the Node as reported by the
// agent.
type NodeDescription struct {
	// EngineDescription provides information about an engine.
	Engine   *EngineDescription `json:"Engine,omitempty"`
	Hostname *string            `json:"Hostname,omitempty"`

	// Platform represents the platform (Arch/OS).
	Platform *Platform `json:"Platform,omitempty"`

	// An object describing the resources which can be advertised by a node and
	// requested by a task.
	Resources *ResourceObject `json:"Resources,omitempty"`

	// Information about the issuer of leaf TLS certificates and the trusted root
	// CA certificate.
	TLSInfo *TLSInfo `json:"TLSInfo,omitempty"`
}

// NodeSpec defines model for NodeSpec.
type NodeSpec struct {
	// Availability of the node.
	Availability *NodeSpecAvailability `json:"Availability,omitempty"`

	// User-defined key/value metadata.
	Labels *NodeSpec_Labels `json:"Labels,omitempty"`

	// Name for the node.
	Name *string `json:"Name,omitempty"`

	// Role of the node.
	Role *NodeSpecRole `json:"Role,omitempty"`
}

// User-defined key/value metadata.
type NodeSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// NodeStatus represents the status of a node.
//
// It provides the current status of the node, as seen by the manager.
type NodeStatus struct {
	// IP address of the node.
	Addr    *string `json:"Addr,omitempty"`
	Message *string `json:"Message,omitempty"`

	// NodeState represents the state of a node.
	State *NodeState `json:"State,omitempty"`
}

// The version number of the object such as node, service, etc. This is needed
// to avoid conflicting writes. The client must send the version number along
// with the modified specification when updating these objects.
//
// This approach ensures safe concurrency and determinism in that the change
// on the object may not be applied if the version number has changed from the
// last read. In other words, if two update requests specify the same base
// version, only one of the requests can succeed. As a result, two separate
// update requests that happen at the same time will not unintentionally
// overwrite each other.
type ObjectVersion struct {
	Index *uint64 `json:"Index,omitempty"`
}

// Represents a peer-node in the swarm
type PeerNode struct {
	// IP address and ports at which this node can be reached.
	Addr *string `json:"Addr,omitempty"`

	// Unique identifier of for this node in the swarm.
	NodeID *string `json:"NodeID,omitempty"`
}

// Platform represents the platform (Arch/OS).
type Platform struct {
	// Architecture represents the hardware architecture (for example,
	// `x86_64`).
	Architecture *string `json:"Architecture,omitempty"`

	// OS represents the Operating System (for example, `linux` or `windows`).
	OS *string `json:"OS,omitempty"`
}

// Describes a permission the user has to accept upon installing
// the plugin.
type PluginPrivilege struct {
	Description *string  `json:"Description,omitempty"`
	Name        *string  `json:"Name,omitempty"`
	Value       []string `json:"Value,omitempty"`
}

// Available plugins per type.
//
// <p><br /></p>
//
// > **Note**: Only unmanaged (V1) plugins are included in this list.
// > V1 plugins are "lazily" loaded, and are not returned in this list
// > if there is no resource using the plugin.
type PluginsInfo struct {
	// Names of available authorization plugins.
	Authorization []string `json:"Authorization,omitempty"`

	// Names of available logging-drivers, and logging-driver plugins.
	Log []string `json:"Log,omitempty"`

	// Names of available network-drivers, and network-driver plugins.
	Network []string `json:"Network,omitempty"`

	// Names of available volume-drivers, and network-driver plugins.
	Volume []string `json:"Volume,omitempty"`
}

// An open port on a container
type Port struct {
	// Host IP address that the container's port is mapped to
	IP *string `json:"IP,omitempty"`

	// Port on the container
	PrivatePort uint16 `json:"PrivatePort"`

	// Port exposed on the host
	PublicPort *uint16  `json:"PublicPort,omitempty"`
	Type       PortType `json:"Type"`
}

// PortBinding represents a binding between a host IP address and a host
// port.
type PortBinding struct {
	// Host IP address that the container's port is mapped to.
	HostIP *string `json:"HostIp,omitempty"`

	// Host port number that the container's port is mapped to.
	HostPort        *string `json:"HostPort,omitempty"`
	IngressProtocol *string `json:"IngressProtocol,omitempty"`
}

// PortMap describes the mapping of container ports to host ports, using the
// container's port-number and protocol as key in the format `<port>/<protocol>`,
// for example, `80/udp`.
//
// If a container's port is mapped for multiple protocols, separate entries
// are added to the mapping table.
type PortMap struct {
	AdditionalProperties map[string][]PortBinding `json:"-"`
}

// RegistryServiceConfig stores daemon registry services configuration.
type RegistryServiceConfig struct {
	// List of IP ranges to which nondistributable artifacts can be pushed,
	// using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).
	//
	// Some images (for example, Windows base images) contain artifacts
	// whose distribution is restricted by license. When these images are
	// pushed to a registry, restricted artifacts are not included.
	//
	// This configuration override this behavior, and enables the daemon to
	// push nondistributable artifacts to all registries whose resolved IP
	// address is within the subnet described by the CIDR syntax.
	//
	// This option is useful when pushing images containing
	// nondistributable artifacts to a registry on an air-gapped network so
	// hosts on that network can pull the images without connecting to
	// another server.
	//
	// > **Warning**: Nondistributable artifacts typically have restrictions
	// > on how and where they can be distributed and shared. Only use this
	// > feature to push artifacts to private registries and ensure that you
	// > are in compliance with any terms that cover redistributing
	// > nondistributable artifacts.
	AllowNondistributableArtifactsCIDRs []string `json:"AllowNondistributableArtifactsCIDRs,omitempty"`

	// List of registry hostnames to which nondistributable artifacts can be
	// pushed, using the format `<hostname>[:<port>]` or `<IP address>[:<port>]`.
	//
	// Some images (for example, Windows base images) contain artifacts
	// whose distribution is restricted by license. When these images are
	// pushed to a registry, restricted artifacts are not included.
	//
	// This configuration override this behavior for the specified
	// registries.
	//
	// This option is useful when pushing images containing
	// nondistributable artifacts to a registry on an air-gapped network so
	// hosts on that network can pull the images without connecting to
	// another server.
	//
	// > **Warning**: Nondistributable artifacts typically have restrictions
	// > on how and where they can be distributed and shared. Only use this
	// > feature to push artifacts to private registries and ensure that you
	// > are in compliance with any terms that cover redistributing
	// > nondistributable artifacts.
	AllowNondistributableArtifactsHostnames []string                            `json:"AllowNondistributableArtifactsHostnames,omitempty"`
	IndexConfigs                            *RegistryServiceConfig_IndexConfigs `json:"IndexConfigs,omitempty"`

	// List of IP ranges of insecure registries, using the CIDR syntax
	// ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries
	// accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates
	// from unknown CAs) communication.
	//
	// By default, local registries (`127.0.0.0/8`) are configured as
	// insecure. All other registries are secure. Communicating with an
	// insecure registry is not possible if the daemon assumes that registry
	// is secure.
	//
	// This configuration override this behavior, insecure communication with
	// registries whose resolved IP address is within the subnet described by
	// the CIDR syntax.
	//
	// Registries can also be marked insecure by hostname. Those registries
	// are listed under `IndexConfigs` and have their `Secure` field set to
	// `false`.
	//
	// > **Warning**: Using this option can be useful when running a local
	// > registry, but introduces security vulnerabilities. This option
	// > should therefore ONLY be used for testing purposes. For increased
	// > security, users should add their CA to their system's list of trusted
	// > CAs instead of enabling this option.
	InsecureRegistryCIDRs []string `json:"InsecureRegistryCIDRs,omitempty"`

	// List of registry URLs that act as a mirror for the official
	// (`docker.io`) registry.
	Mirrors []string `json:"Mirrors,omitempty"`
}

// RegistryServiceConfig_IndexConfigs defines model for RegistryServiceConfig.IndexConfigs.
type RegistryServiceConfig_IndexConfigs struct {
	AdditionalProperties map[string]IndexInfo `json:"-"`
}

// An object describing the resources which can be advertised by a node and
// requested by a task.
type ResourceObject struct {
	// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
	// String resources (e.g, `GPU=UUID1`).
	GenericResources *GenericResources `json:"GenericResources,omitempty"`
	MemoryBytes      *int64            `json:"MemoryBytes,omitempty"`
	NanoCPUS         *int64            `json:"NanoCPUs,omitempty"`
}

// A container's resources (cgroups config, ulimits, etc)
type Resources struct {
	// Limit read rate (bytes per second) from a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceReadBps []ThrottleDevice `json:"BlkioDeviceReadBps,omitempty"`

	// Limit read rate (IO per second) from a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceReadIOps []ThrottleDevice `json:"BlkioDeviceReadIOps,omitempty"`

	// Limit write rate (bytes per second) to a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceWriteBps []ThrottleDevice `json:"BlkioDeviceWriteBps,omitempty"`

	// Limit write rate (IO per second) to a device, in the form:
	//
	// ```
	// [{"Path": "device_path", "Rate": rate}]
	// ```
	BlkioDeviceWriteIOps []ThrottleDevice `json:"BlkioDeviceWriteIOps,omitempty"`

	// Block IO weight (relative weight).
	BlkioWeight *int `json:"BlkioWeight,omitempty"`

	// Block IO weight (relative device weight) in the form:
	//
	// ```
	// [{"Path": "device_path", "Weight": weight}]
	// ```
	BlkioWeightDevice []struct {
		Path   *string `json:"Path,omitempty"`
		Weight *int    `json:"Weight,omitempty"`
	} `json:"BlkioWeightDevice,omitempty"`

	// Path to `cgroups` under which the container's `cgroup` is created. If
	// the path is not absolute, the path is considered to be relative to the
	// `cgroups` path of the init process. Cgroups are created if they do not
	// already exist.
	CgroupParent *string `json:"CgroupParent,omitempty"`

	// The number of usable CPUs (Windows only).
	//
	// On Windows Server containers, the processor resource controls are
	// mutually exclusive. The order of precedence is `CPUCount` first, then
	// `CPUShares`, and `CPUPercent` last.
	CPUCount *int64 `json:"CpuCount,omitempty"`

	// The usable percentage of the available CPUs (Windows only).
	//
	// On Windows Server containers, the processor resource controls are
	// mutually exclusive. The order of precedence is `CPUCount` first, then
	// `CPUShares`, and `CPUPercent` last.
	CPUPercent *int64 `json:"CpuPercent,omitempty"`

	// The length of a CPU period in microseconds.
	CPUPeriod *int64 `json:"CpuPeriod,omitempty"`

	// Microseconds of CPU time that the container can get in a CPU period.
	CPUQuota *int64 `json:"CpuQuota,omitempty"`

	// The length of a CPU real-time period in microseconds. Set to 0 to
	// allocate no time allocated to real-time tasks.
	CPURealtimePeriod *int64 `json:"CpuRealtimePeriod,omitempty"`

	// The length of a CPU real-time runtime in microseconds. Set to 0 to
	// allocate no time allocated to real-time tasks.
	CPURealtimeRuntime *int64 `json:"CpuRealtimeRuntime,omitempty"`

	// An integer value representing this container's relative CPU weight
	// versus other containers.
	CPUShares *int `json:"CpuShares,omitempty"`

	// CPUs in which to allow execution (e.g., `0-3`, `0,1`).
	CpusetCpus *string `json:"CpusetCpus,omitempty"`

	// Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only
	// effective on NUMA systems.
	CpusetMems *string `json:"CpusetMems,omitempty"`

	// a list of cgroup rules to apply to the container
	DeviceCgroupRules []string `json:"DeviceCgroupRules,omitempty"`

	// A list of requests for devices to be sent to device drivers.
	DeviceRequests []DeviceRequest `json:"DeviceRequests,omitempty"`

	// A list of devices to add to the container.
	Devices []DeviceMapping `json:"Devices,omitempty"`

	// Maximum IO in bytes per second for the container system drive
	// (Windows only).
	IOMaximumBandwidth *int64 `json:"IOMaximumBandwidth,omitempty"`

	// Maximum IOps for the container system drive (Windows only)
	IOMaximumIOps *int64 `json:"IOMaximumIOps,omitempty"`

	// Run an init inside the container that forwards signals and reaps
	// processes. This field is omitted if empty, and the default (as
	// configured on the daemon) is used.
	Init *bool `json:"Init,omitempty"`

	// Kernel memory limit in bytes.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is deprecated as the kernel 5.4 deprecated
	// > `kmem.limit_in_bytes`.
	KernelMemory *int64 `json:"KernelMemory,omitempty"`

	// Hard limit for kernel TCP buffer memory (in bytes).
	KernelMemoryTCP *int64 `json:"KernelMemoryTCP,omitempty"`

	// Memory limit in bytes.
	Memory *int64 `json:"Memory,omitempty"`

	// Memory soft limit in bytes.
	MemoryReservation *int64 `json:"MemoryReservation,omitempty"`

	// Total memory limit (memory + swap). Set as `-1` to enable unlimited
	// swap.
	MemorySwap *int64 `json:"MemorySwap,omitempty"`

	// Tune a container's memory swappiness behavior. Accepts an integer
	// between 0 and 100.
	MemorySwappiness *int64 `json:"MemorySwappiness,omitempty"`

	// CPU quota in units of 10<sup>-9</sup> CPUs.
	NanoCpus *int64 `json:"NanoCpus,omitempty"`

	// Disable OOM Killer for the container.
	OomKillDisable *bool `json:"OomKillDisable,omitempty"`

	// Tune a container's PIDs limit. Set `0` or `-1` for unlimited, or `null`
	// to not change.
	PidsLimit *int64 `json:"PidsLimit,omitempty"`

	// A list of resource limits to set in the container. For example:
	//
	// ```
	// {"Name": "nofile", "Soft": 1024, "Hard": 2048}
	// ```
	Ulimits []struct {
		// Hard limit
		Hard *int `json:"Hard,omitempty"`

		// Name of ulimit
		Name *string `json:"Name,omitempty"`

		// Soft limit
		Soft *int `json:"Soft,omitempty"`
	} `json:"Ulimits,omitempty"`
}

// The behavior to apply when the container exits. The default is not to
// restart.
//
// An ever increasing delay (double the previous delay, starting at 100ms) is
// added before each restart to prevent flooding the server.
type RestartPolicy struct {
	// If `on-failure` is used, the number of times to retry before giving up.
	MaximumRetryCount *int `json:"MaximumRetryCount,omitempty"`

	// - Empty string means not to restart
	// - `no` Do not automatically restart
	// - `always` Always restart
	// - `unless-stopped` Restart always except when the user has manually stopped the container
	// - `on-failure` Restart only when the container exit code is non-zero
	Name *RestartPolicyName `json:"Name,omitempty"`
}

// Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec)
// runtime.
//
// The runtime is invoked by the daemon via the `containerd` daemon. OCI
// runtimes act as an interface to the Linux kernel namespaces, cgroups,
// and SELinux.
type Runtime struct {
	// Name and, optional, path, of the OCI executable binary.
	//
	// If the path is omitted, the daemon searches the host's `$PATH` for the
	// binary and uses the first result.
	Path *string `json:"path,omitempty"`

	// List of command-line arguments to pass to the runtime when invoked.
	RuntimeArgs []string `json:"runtimeArgs,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	CreatedAt *string     `json:"CreatedAt,omitempty"`
	ID        *string     `json:"ID,omitempty"`
	Spec      *SecretSpec `json:"Spec,omitempty"`
	UpdatedAt *string     `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// SecretSpec defines model for SecretSpec.
type SecretSpec struct {
	// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
	// data to store as secret.
	//
	// This field is only used to _create_ a secret, and is not returned by
	// other endpoints.
	Data *string `json:"Data,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Driver *Driver `json:"Driver,omitempty"`

	// User-defined key/value metadata.
	Labels *SecretSpec_Labels `json:"Labels,omitempty"`

	// User-defined name of the secret.
	Name *string `json:"Name,omitempty"`

	// Driver represents a driver (network, logging, secrets).
	Templating *Driver `json:"Templating,omitempty"`
}

// User-defined key/value metadata.
type SecretSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Service defines model for Service.
type Service struct {
	CreatedAt *string          `json:"CreatedAt,omitempty"`
	Endpoint  *ServiceEndpoint `json:"Endpoint,omitempty"`
	ID        *string          `json:"ID,omitempty"`

	// The status of the service when it is in one of ReplicatedJob or
	// GlobalJob modes. Absent on Replicated and Global mode services. The
	// JobIteration is an ObjectVersion, but unlike the Service's version,
	// does not need to be sent with an update request.
	JobStatus *ServiceJobStatus `json:"JobStatus,omitempty"`

	// The status of the service's tasks. Provided only when requested as
	// part of a ServiceList operation.
	ServiceStatus *ServiceStatus `json:"ServiceStatus,omitempty"`

	// User modifiable configuration for a service.
	Spec *ServiceSpec `json:"Spec,omitempty"`

	// The status of a service update.
	UpdateStatus *ServiceUpdateStatus `json:"UpdateStatus,omitempty"`
	UpdatedAt    *string              `json:"UpdatedAt,omitempty"`

	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	Version *ObjectVersion `json:"Version,omitempty"`
}

// ServiceEndpoint defines model for ServiceEndpoint.
type ServiceEndpoint struct {
	Ports []EndpointPortConfig `json:"Ports,omitempty"`

	// Properties that can be configured to access and load balance a service.
	Spec       *EndpointSpec `json:"Spec,omitempty"`
	VirtualIPS []struct {
		Addr      *string `json:"Addr,omitempty"`
		NetworkID *string `json:"NetworkID,omitempty"`
	} `json:"VirtualIPs,omitempty"`
}

// The status of the service when it is in one of ReplicatedJob or
// GlobalJob modes. Absent on Replicated and Global mode services. The
// JobIteration is an ObjectVersion, but unlike the Service's version,
// does not need to be sent with an update request.
type ServiceJobStatus struct {
	// The version number of the object such as node, service, etc. This is needed
	// to avoid conflicting writes. The client must send the version number along
	// with the modified specification when updating these objects.
	//
	// This approach ensures safe concurrency and determinism in that the change
	// on the object may not be applied if the version number has changed from the
	// last read. In other words, if two update requests specify the same base
	// version, only one of the requests can succeed. As a result, two separate
	// update requests that happen at the same time will not unintentionally
	// overwrite each other.
	JobIteration *ObjectVersion `json:"JobIteration,omitempty"`

	// The last time, as observed by the server, that this job was
	// started.
	LastExecution *string `json:"LastExecution,omitempty"`
}

// User modifiable configuration for a service.
type ServiceSpec struct {
	// Properties that can be configured to access and load balance a service.
	EndpointSpec *EndpointSpec `json:"EndpointSpec,omitempty"`

	// User-defined key/value metadata.
	Labels *ServiceSpec_Labels `json:"Labels,omitempty"`

	// Scheduling mode for the service.
	Mode *ServiceSpecMode `json:"Mode,omitempty"`

	// Name of the service.
	Name *string `json:"Name,omitempty"`

	// Specifies which networks the service should attach to.
	Networks []NetworkAttachmentConfig `json:"Networks,omitempty"`

	// Specification for the rollback strategy of the service.
	RollbackConfig *struct {
		// Amount of time between rollback iterations, in nanoseconds.
		Delay *int64 `json:"Delay,omitempty"`

		// Action to take if an rolled back task fails to run, or stops
		// running during the rollback.
		FailureAction *ServiceSpecRollbackConfigFailureAction `json:"FailureAction,omitempty"`

		// The fraction of tasks that may fail during a rollback before the
		// failure action is invoked, specified as a floating point number
		// between 0 and 1.
		MaxFailureRatio *float32 `json:"MaxFailureRatio,omitempty"`

		// Amount of time to monitor each rolled back task for failures, in
		// nanoseconds.
		Monitor *int64 `json:"Monitor,omitempty"`

		// The order of operations when rolling back a task. Either the old
		// task is shut down before the new task is started, or the new task
		// is started before the old task is shut down.
		Order *ServiceSpecRollbackConfigOrder `json:"Order,omitempty"`

		// Maximum number of tasks to be rolled back in one iteration (0 means
		// unlimited parallelism).
		Parallelism *int64 `json:"Parallelism,omitempty"`
	} `json:"RollbackConfig,omitempty"`

	// User modifiable task configuration.
	TaskTemplate *TaskSpec `json:"TaskTemplate,omitempty"`

	// Specification for the update strategy of the service.
	UpdateConfig *struct {
		// Amount of time between updates, in nanoseconds.
		Delay *int64 `json:"Delay,omitempty"`

		// Action to take if an updated task fails to run, or stops running
		// during the update.
		FailureAction *ServiceSpecUpdateConfigFailureAction `json:"FailureAction,omitempty"`

		// The fraction of tasks that may fail during an update before the
		// failure action is invoked, specified as a floating point number
		// between 0 and 1.
		MaxFailureRatio *float32 `json:"MaxFailureRatio,omitempty"`

		// Amount of time to monitor each updated task for failures, in
		// nanoseconds.
		Monitor *int64 `json:"Monitor,omitempty"`

		// The order of operations when rolling out an updated task. Either
		// the old task is shut down before the new task is started, or the
		// new task is started before the old task is shut down.
		Order *ServiceSpecUpdateConfigOrder `json:"Order,omitempty"`

		// Maximum number of tasks to be updated in one iteration (0 means
		// unlimited parallelism).
		Parallelism *int64 `json:"Parallelism,omitempty"`
	} `json:"UpdateConfig,omitempty"`
}

// User-defined key/value metadata.
type ServiceSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Scheduling mode for the service.
type ServiceSpecMode struct {
	Replicated *ServiceSpecModeReplicated `json:"Replicated,omitempty"`
}

// ServiceSpecModeReplicated defines model for ServiceSpecModeReplicated.
type ServiceSpecModeReplicated struct {
	Replicas *int64 `json:"Replicas,omitempty"`
}

// The status of the service's tasks. Provided only when requested as
// part of a ServiceList operation.
type ServiceStatus struct {
	// The number of tasks for a job that are in the Completed state.
	// This field must be cross-referenced with the service type, as the
	// value of 0 may mean the service is not in a job mode, or it may
	// mean the job-mode service has no tasks yet Completed.
	CompletedTasks *uint64 `json:"CompletedTasks,omitempty"`

	// The number of tasks for the service desired to be running.
	// For replicated services, this is the replica count from the
	// service spec. For global services, this is computed by taking
	// count of all tasks for the service with a Desired State other
	// than Shutdown.
	DesiredTasks *uint64 `json:"DesiredTasks,omitempty"`

	// The number of tasks for the service currently in the Running state.
	RunningTasks *uint64 `json:"RunningTasks,omitempty"`
}

// The status of a service update.
type ServiceUpdateStatus struct {
	CompletedAt *string                   `json:"CompletedAt,omitempty"`
	Message     *string                   `json:"Message,omitempty"`
	StartedAt   *string                   `json:"StartedAt,omitempty"`
	State       *ServiceUpdateStatusState `json:"State,omitempty"`
}

// Represents generic information about swarm.
type SwarmInfo struct {
	// ClusterInfo represents information about the swarm as is returned by the
	// "/info" endpoint. Join-tokens are not included.
	Cluster          *ClusterInfo `json:"Cluster,omitempty"`
	ControlAvailable *bool        `json:"ControlAvailable,omitempty"`
	Error            *string      `json:"Error,omitempty"`

	// Current local status of this node.
	LocalNodeState *LocalNodeState `json:"LocalNodeState,omitempty"`

	// Total number of managers in the swarm.
	Managers *int `json:"Managers,omitempty"`

	// IP address at which this node can be reached by other nodes in the
	// swarm.
	NodeAddr *string `json:"NodeAddr,omitempty"`

	// Unique identifier of for this node in the swarm.
	NodeID *string `json:"NodeID,omitempty"`

	// Total number of nodes in the swarm.
	Nodes *int `json:"Nodes,omitempty"`

	// List of ID's and addresses of other managers in the swarm.
	RemoteManagers []PeerNode `json:"RemoteManagers,omitempty"`
}

// User modifiable swarm configuration.
type SwarmSpec struct {
	// CA configuration.
	CAConfig *struct {
		// Configuration for forwarding signing requests to an external
		// certificate authority.
		ExternalCAs []struct {
			// The root CA certificate (in PEM format) this external CA uses
			// to issue TLS certificates (assumed to be to the current swarm
			// root CA certificate if not provided).
			CACert *string `json:"CACert,omitempty"`

			// An object with key/value pairs that are interpreted as
			// protocol-specific options for the external CA driver.
			Options *SwarmSpec_CAConfig_ExternalCAs_Options `json:"Options,omitempty"`

			// Protocol for communication with the external CA (currently
			// only `cfssl` is supported).
			Protocol *SwarmSpecCAConfigExternalCAsProtocol `json:"Protocol,omitempty"`

			// URL where certificate signing requests should be sent.
			URL *string `json:"URL,omitempty"`
		} `json:"ExternalCAs,omitempty"`

		// An integer whose purpose is to force swarm to generate a new
		// signing CA certificate and key, if none have been specified in
		// `SigningCACert` and `SigningCAKey`
		ForceRotate *uint64 `json:"ForceRotate,omitempty"`

		// The duration node certificates are issued for.
		NodeCertExpiry *int64 `json:"NodeCertExpiry,omitempty"`

		// The desired signing CA certificate for all swarm node TLS leaf
		// certificates, in PEM format.
		SigningCACert *string `json:"SigningCACert,omitempty"`

		// The desired signing CA key for all swarm node TLS leaf certificates,
		// in PEM format.
		SigningCAKey *string `json:"SigningCAKey,omitempty"`
	} `json:"CAConfig,omitempty"`

	// Dispatcher configuration.
	Dispatcher *struct {
		// The delay for an agent to send a heartbeat to the dispatcher.
		HeartbeatPeriod *int64 `json:"HeartbeatPeriod,omitempty"`
	} `json:"Dispatcher,omitempty"`

	// Parameters related to encryption-at-rest.
	EncryptionConfig *struct {
		// If set, generate a key and use it to lock data stored on the
		// managers.
		AutoLockManagers *bool `json:"AutoLockManagers,omitempty"`
	} `json:"EncryptionConfig,omitempty"`

	// User-defined key/value metadata.
	Labels *SwarmSpec_Labels `json:"Labels,omitempty"`

	// Name of the swarm.
	Name *string `json:"Name,omitempty"`

	// Orchestration configuration.
	Orchestration *struct {
		// The number of historic tasks to keep per instance or node. If
		// negative, never remove completed or failed tasks.
		TaskHistoryRetentionLimit *int64 `json:"TaskHistoryRetentionLimit,omitempty"`
	} `json:"Orchestration,omitempty"`

	// Raft configuration.
	Raft *struct {
		// The number of ticks that a follower will wait for a message from
		// the leader before becoming a candidate and starting an election.
		// `ElectionTick` must be greater than `HeartbeatTick`.
		//
		// A tick currently defaults to one second, so these translate
		// directly to seconds currently, but this is NOT guaranteed.
		ElectionTick *int `json:"ElectionTick,omitempty"`

		// The number of ticks between heartbeats. Every HeartbeatTick ticks,
		// the leader will send a heartbeat to the followers.
		//
		// A tick currently defaults to one second, so these translate
		// directly to seconds currently, but this is NOT guaranteed.
		HeartbeatTick *int `json:"HeartbeatTick,omitempty"`

		// The number of snapshots to keep beyond the current snapshot.
		KeepOldSnapshots *uint64 `json:"KeepOldSnapshots,omitempty"`

		// The number of log entries to keep around to sync up slow followers
		// after a snapshot is created.
		LogEntriesForSlowFollowers *uint64 `json:"LogEntriesForSlowFollowers,omitempty"`

		// The number of log entries between snapshots.
		SnapshotInterval *uint64 `json:"SnapshotInterval,omitempty"`
	} `json:"Raft,omitempty"`

	// Defaults for creating tasks in this cluster.
	TaskDefaults *struct {
		// The log driver to use for tasks created in the orchestrator if
		// unspecified by a service.
		//
		// Updating this value only affects new tasks. Existing tasks continue
		// to use their previously configured log driver until recreated.
		LogDriver *struct {
			// The log driver to use as a default for new tasks.
			Name *string `json:"Name,omitempty"`

			// Driver-specific options for the selectd log driver, specified
			// as key/value pairs.
			Options *SwarmSpec_TaskDefaults_LogDriver_Options `json:"Options,omitempty"`
		} `json:"LogDriver,omitempty"`
	} `json:"TaskDefaults,omitempty"`
}

// An object with key/value pairs that are interpreted as
// protocol-specific options for the external CA driver.
type SwarmSpec_CAConfig_ExternalCAs_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// User-defined key/value metadata.
type SwarmSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Driver-specific options for the selectd log driver, specified
// as key/value pairs.
type SwarmSpec_TaskDefaults_LogDriver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	// Hardware architecture of the host, as returned by the Go runtime
	// (`GOARCH`).
	//
	// A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
	Architecture *string `json:"Architecture,omitempty"`

	// Indicates if `bridge-nf-call-ip6tables` is available on the host.
	BridgeNfIp6tables *bool `json:"BridgeNfIp6tables,omitempty"`

	// Indicates if `bridge-nf-call-iptables` is available on the host.
	BridgeNfIptables *bool `json:"BridgeNfIptables,omitempty"`

	// Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.
	//
	// See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt)
	CPUSet *bool `json:"CPUSet,omitempty"`

	// Indicates if CPU Shares limiting is supported by the host.
	CPUShares *bool `json:"CPUShares,omitempty"`

	// The driver to use for managing cgroups.
	CgroupDriver *SystemInfoCgroupDriver `json:"CgroupDriver,omitempty"`

	// The version of the cgroup.
	CgroupVersion *SystemInfoCgroupVersion `json:"CgroupVersion,omitempty"`

	// The network endpoint that the Engine advertises for the purpose of
	// node discovery. ClusterAdvertise is a `host:port` combination on which
	// the daemon is reachable by other hosts.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when using standalone Swarm
	// > mode, and overlay networking using an external k/v store. Overlay
	// > networks with Swarm mode enabled use the built-in raft store, and
	// > this field will be empty.
	ClusterAdvertise *string `json:"ClusterAdvertise,omitempty"`

	// URL of the distributed storage backend.
	//
	//
	// The storage backend is used for multihost networking (to store
	// network and endpoint information) and by the node discovery mechanism.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is only propagated when using standalone Swarm
	// > mode, and overlay networking using an external k/v store. Overlay
	// > networks with Swarm mode enabled use the built-in raft store, and
	// > this field will be empty.
	ClusterStore *string `json:"ClusterStore,omitempty"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	ContainerdCommit *Commit `json:"ContainerdCommit,omitempty"`

	// Total number of containers on the host.
	Containers *int `json:"Containers,omitempty"`

	// Number of containers with status `"paused"`.
	ContainersPaused *int `json:"ContainersPaused,omitempty"`

	// Number of containers with status `"running"`.
	ContainersRunning *int `json:"ContainersRunning,omitempty"`

	// Number of containers with status `"stopped"`.
	ContainersStopped *int `json:"ContainersStopped,omitempty"`

	// Indicates if CPU CFS(Completely Fair Scheduler) period is supported by
	// the host.
	CPUCfsPeriod *bool `json:"CpuCfsPeriod,omitempty"`

	// Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by
	// the host.
	CPUCfsQuota *bool `json:"CpuCfsQuota,omitempty"`

	// Indicates if the daemon is running in debug-mode / with debug-level
	// logging enabled.
	Debug *bool `json:"Debug,omitempty"`

	// List of custom default address pools for local networks, which can be
	// specified in the daemon.json file or dockerd option.
	//
	// Example: a Base "10.10.0.0/16" with Size 24 will define the set of 256
	// 10.10.[0-255].0/24 address pools.
	DefaultAddressPools []struct {
		// The network address in CIDR format
		Base *string `json:"Base,omitempty"`

		// The network pool size
		Size *int `json:"Size,omitempty"`
	} `json:"DefaultAddressPools,omitempty"`

	// Name of the default OCI runtime that is used when starting containers.
	//
	// The default can be overridden per-container at create time.
	DefaultRuntime *string `json:"DefaultRuntime,omitempty"`

	// Root directory of persistent Docker state.
	//
	// Defaults to `/var/lib/docker` on Linux, and `C:\ProgramData\docker`
	// on Windows.
	DockerRootDir *string `json:"DockerRootDir,omitempty"`

	// Name of the storage driver in use.
	Driver *string `json:"Driver,omitempty"`

	// Information specific to the storage driver, provided as
	// "label" / "value" pairs.
	//
	// This information is provided by the storage driver, and formatted
	// in a way consistent with the output of `docker info` on the command
	// line.
	//
	// <p><br /></p>
	//
	// > **Note**: The information returned in this field, including the
	// > formatting of values and labels, should not be considered stable,
	// > and may change without notice.
	DriverStatus [][]string `json:"DriverStatus,omitempty"`

	// Indicates if experimental features are enabled on the daemon.
	ExperimentalBuild *bool `json:"ExperimentalBuild,omitempty"`

	// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
	// String resources (e.g, `GPU=UUID1`).
	GenericResources *GenericResources `json:"GenericResources,omitempty"`

	// HTTP-proxy configured for the daemon. This value is obtained from the
	// [`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
	// Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
	// are masked in the API response.
	//
	// Containers do not automatically inherit this configuration.
	HTTPProxy *string `json:"HttpProxy,omitempty"`

	// HTTPS-proxy configured for the daemon. This value is obtained from the
	// [`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
	// Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
	// are masked in the API response.
	//
	// Containers do not automatically inherit this configuration.
	HTTPSProxy *string `json:"HttpsProxy,omitempty"`

	// Unique identifier of the daemon.
	//
	// <p><br /></p>
	//
	// > **Note**: The format of the ID itself is not part of the API, and
	// > should not be considered stable.
	ID *string `json:"ID,omitempty"`

	// Indicates IPv4 forwarding is enabled.
	IPV4forwarding *bool `json:"IPv4Forwarding,omitempty"`

	// Total number of images on the host.
	//
	// Both _tagged_ and _untagged_ (dangling) images are counted.
	Images *int `json:"Images,omitempty"`

	// Address / URL of the index server that is used for image search,
	// and as a default for user authentication for Docker Hub and Docker Cloud.
	IndexServerAddress *string `json:"IndexServerAddress,omitempty"`

	// Name and, optional, path of the `docker-init` binary.
	//
	// If the path is omitted, the daemon searches the host's `$PATH` for the
	// binary and uses the first result.
	InitBinary *string `json:"InitBinary,omitempty"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	InitCommit *Commit `json:"InitCommit,omitempty"`

	// Represents the isolation technology to use as a default for containers.
	// The supported values are platform-specific.
	//
	// If no isolation value is specified on daemon start, on Windows client,
	// the default is `hyperv`, and on Windows server, the default is `process`.
	//
	// This option is currently not used on other platforms.
	Isolation *SystemInfoIsolation `json:"Isolation,omitempty"`

	// Indicates if the host has kernel memory limit support enabled.
	//
	// <p><br /></p>
	//
	// > **Deprecated**: This field is deprecated as the kernel 5.4 deprecated
	// > `kmem.limit_in_bytes`.
	KernelMemory *bool `json:"KernelMemory,omitempty"`

	// Indicates if the host has kernel memory TCP limit support enabled.
	//
	// Kernel memory TCP limits are not supported when using cgroups v2, which
	// does not support the corresponding `memory.kmem.tcp.limit_in_bytes` cgroup.
	KernelMemoryTCP *bool `json:"KernelMemoryTCP,omitempty"`

	// Kernel version of the host.
	//
	// On Linux, this information obtained from `uname`. On Windows this
	// information is queried from the <kbd>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\</kbd>
	// registry value, for example _"10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)"_.
	KernelVersion *string `json:"KernelVersion,omitempty"`

	// User-defined labels (key/value metadata) as set on the daemon.
	//
	// <p><br /></p>
	//
	// > **Note**: When part of a Swarm, nodes can both have _daemon_ labels,
	// > set through the daemon configuration, and _node_ labels, set from a
	// > manager node in the Swarm. Node labels are not included in this
	// > field. Node labels can be retrieved using the `/nodes/(id)` endpoint
	// > on a manager node in the Swarm.
	Labels []string `json:"Labels,omitempty"`

	// Indicates if live restore is enabled.
	//
	// If enabled, containers are kept running when the daemon is shutdown
	// or upon daemon start if running containers are detected.
	LiveRestoreEnabled *bool `json:"LiveRestoreEnabled,omitempty"`

	// The logging driver to use as a default for new containers.
	LoggingDriver *string `json:"LoggingDriver,omitempty"`

	// Total amount of physical memory available on the host, in bytes.
	MemTotal *int64 `json:"MemTotal,omitempty"`

	// Indicates if the host has memory limit support enabled.
	MemoryLimit *bool `json:"MemoryLimit,omitempty"`

	// The number of logical CPUs usable by the daemon.
	//
	// The number of available CPUs is checked by querying the operating
	// system when the daemon starts. Changes to operating system CPU
	// allocation after the daemon is started are not reflected.
	NCPU *int `json:"NCPU,omitempty"`

	// Number of event listeners subscribed.
	NEventsListener *int `json:"NEventsListener,omitempty"`

	// The total number of file Descriptors in use by the daemon process.
	//
	// This information is only returned if debug-mode is enabled.
	NFd *int `json:"NFd,omitempty"`

	// The  number of goroutines that currently exist.
	//
	// This information is only returned if debug-mode is enabled.
	NGoroutines *int `json:"NGoroutines,omitempty"`

	// Hostname of the host.
	Name *string `json:"Name,omitempty"`

	// Comma-separated list of domain extensions for which no proxy should be
	// used. This value is obtained from the [`NO_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html)
	// environment variable.
	//
	// Containers do not automatically inherit this configuration.
	NoProxy *string `json:"NoProxy,omitempty"`

	// Generic type of the operating system of the host, as returned by the
	// Go runtime (`GOOS`).
	//
	// Currently returned values are "linux" and "windows". A full list of
	// possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
	OSType *string `json:"OSType,omitempty"`

	// Version of the host's operating system
	//
	// <p><br /></p>
	//
	// > **Note**: The information returned in this field, including its
	// > very existence, and the formatting of values, should not be considered
	// > stable, and may change without notice.
	OSVersion *string `json:"OSVersion,omitempty"`

	// Indicates if OOM killer disable is supported on the host.
	OomKillDisable *bool `json:"OomKillDisable,omitempty"`

	// Name of the host's operating system, for example: "Ubuntu 16.04.2 LTS"
	// or "Windows Server 2016 Datacenter"
	OperatingSystem *string `json:"OperatingSystem,omitempty"`

	// Indicates if the host kernel has PID limit support enabled.
	PidsLimit *bool `json:"PidsLimit,omitempty"`

	// Available plugins per type.
	//
	// <p><br /></p>
	//
	// > **Note**: Only unmanaged (V1) plugins are included in this list.
	// > V1 plugins are "lazily" loaded, and are not returned in this list
	// > if there is no resource using the plugin.
	Plugins *PluginsInfo `json:"Plugins,omitempty"`

	// Reports a summary of the product license on the daemon.
	//
	// If a commercial license has been applied to the daemon, information
	// such as number of nodes, and expiration are included.
	ProductLicense *string `json:"ProductLicense,omitempty"`

	// RegistryServiceConfig stores daemon registry services configuration.
	RegistryConfig *RegistryServiceConfig `json:"RegistryConfig,omitempty"`

	// Commit holds the Git-commit (SHA1) that a binary was built from, as
	// reported in the version-string of external tools, such as `containerd`,
	// or `runC`.
	RuncCommit *Commit `json:"RuncCommit,omitempty"`

	// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
	// runtimes configured on the daemon. Keys hold the "name" used to
	// reference the runtime.
	//
	// The Docker daemon relies on an OCI compliant runtime (invoked via the
	// `containerd` daemon) as its interface to the Linux kernel namespaces,
	// cgroups, and SELinux.
	//
	// The default runtime is `runc`, and automatically configured. Additional
	// runtimes can be configured by the user and will be listed here.
	Runtimes *SystemInfo_Runtimes `json:"Runtimes,omitempty"`

	// List of security features that are enabled on the daemon, such as
	// apparmor, seccomp, SELinux, user-namespaces (userns), and rootless.
	//
	// Additional configuration options for each security feature may
	// be present, and are included as a comma-separated list of key/value
	// pairs.
	SecurityOptions []string `json:"SecurityOptions,omitempty"`

	// Version string of the daemon.
	//
	// > **Note**: the [standalone Swarm API](/swarm/swarm-api/)
	// > returns the Swarm version instead of the daemon  version, for example
	// > `swarm/1.2.8`.
	ServerVersion *string `json:"ServerVersion,omitempty"`

	// Indicates if the host has memory swap limit support enabled.
	SwapLimit *bool `json:"SwapLimit,omitempty"`

	// Represents generic information about swarm.
	Swarm *SwarmInfo `json:"Swarm,omitempty"`

	// Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)
	// format with nano-seconds.
	SystemTime *string `json:"SystemTime,omitempty"`

	// List of warnings / informational messages about missing features, or
	// issues related to the daemon configuration.
	//
	// These messages can be printed by the client as information to the user.
	Warnings []string `json:"Warnings,omitempty"`
}

// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
// runtimes configured on the daemon. Keys hold the "name" used to
// reference the runtime.
//
// The Docker daemon relies on an OCI compliant runtime (invoked via the
// `containerd` daemon) as its interface to the Linux kernel namespaces,
// cgroups, and SELinux.
//
// The default runtime is `runc`, and automatically configured. Additional
// runtimes can be configured by the user and will be listed here.
type SystemInfo_Runtimes struct {
	AdditionalProperties map[string]Runtime `json:"-"`
}

// Response of Engine API: GET "/version"
type SystemVersion struct {
	// The default (and highest) API version that is supported by the daemon
	APIVersion *string `json:"ApiVersion,omitempty"`

	// The architecture that the daemon is running on
	Arch *string `json:"Arch,omitempty"`

	// The date and time that the daemon was compiled.
	BuildTime *string `json:"BuildTime,omitempty"`

	// Information about system components
	Components []struct {
		// Key/value pairs of strings with additional information about the
		// component. These values are intended for informational purposes
		// only, and their content is not defined, and not part of the API
		// specification.
		//
		// These messages can be printed by the client as information to the user.
		Details *map[string]interface{} `json:"Details,omitempty"`

		// Name of the component
		Name string `json:"Name"`

		// Version of the component
		Version string `json:"Version"`
	} `json:"Components,omitempty"`

	// Indicates if the daemon is started with experimental features enabled.
	//
	// This field is omitted when empty / false.
	Experimental *bool `json:"Experimental,omitempty"`

	// The Git commit of the source code that was used to build the daemon
	GitCommit *string `json:"GitCommit,omitempty"`

	// The version Go used to compile the daemon, and the version of the Go
	// runtime in use.
	GoVersion *string `json:"GoVersion,omitempty"`

	// The kernel version (`uname -r`) that the daemon is running on.
	//
	// This field is omitted when empty.
	KernelVersion *string `json:"KernelVersion,omitempty"`

	// The minimum API version that is supported by the daemon
	MinAPIVersion *string `json:"MinAPIVersion,omitempty"`

	// The operating system that the daemon is running on ("linux" or "windows")
	Os       *string `json:"Os,omitempty"`
	Platform *struct {
		Name string `json:"Name"`
	} `json:"Platform,omitempty"`

	// The version of the daemon
	Version *string `json:"Version,omitempty"`
}

// Information about the issuer of leaf TLS certificates and the trusted root
// CA certificate.
type TLSInfo struct {
	// The base64-url-safe-encoded raw public key bytes of the issuer.
	CertIssuerPublicKey *string `json:"CertIssuerPublicKey,omitempty"`

	// The base64-url-safe-encoded raw subject bytes of the issuer.
	CertIssuerSubject *string `json:"CertIssuerSubject,omitempty"`

	// The root CA certificate(s) that are used to validate leaf TLS
	// certificates.
	TrustRoot *string `json:"TrustRoot,omitempty"`
}

// User modifiable task configuration.
type TaskSpec struct {
	// Container spec for the service.
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	ContainerSpec *TaskSpecContainerSpec `json:"ContainerSpec,omitempty"`

	// A counter that triggers an update even if no relevant parameters have
	// been changed.
	ForceUpdate *int `json:"ForceUpdate,omitempty"`

	// Specifies the log driver to use for tasks created from this spec. If
	// not present, the default one for the swarm will be used, finally
	// falling back to the engine default if not specified.
	LogDriver *struct {
		Name    *string                     `json:"Name,omitempty"`
		Options *TaskSpec_LogDriver_Options `json:"Options,omitempty"`
	} `json:"LogDriver,omitempty"`

	// Read-only spec type for non-swarm containers attached to swarm overlay
	// networks.
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	NetworkAttachmentSpec *struct {
		// ID of the container represented by this task
		ContainerID *string `json:"ContainerID,omitempty"`
	} `json:"NetworkAttachmentSpec,omitempty"`

	// Specifies which networks the service should attach to.
	Networks  []NetworkAttachmentConfig `json:"Networks,omitempty"`
	Placement *struct {
		// An array of constraint expressions to limit the set of nodes where
		// a task can be scheduled. Constraint expressions can either use a
		// _match_ (`==`) or _exclude_ (`!=`) rule. Multiple constraints find
		// nodes that satisfy every expression (AND match). Constraints can
		// match node or Docker Engine labels as follows:
		//
		// node attribute       | matches                        | example
		// ---------------------|--------------------------------|-----------------------------------------------
		// `node.id`            | Node ID                        | `node.id==2ivku8v2gvtg4`
		// `node.hostname`      | Node hostname                  | `node.hostname!=node-2`
		// `node.role`          | Node role (`manager`/`worker`) | `node.role==manager`
		// `node.platform.os`   | Node operating system          | `node.platform.os==windows`
		// `node.platform.arch` | Node architecture              | `node.platform.arch==x86_64`
		// `node.labels`        | User-defined node labels       | `node.labels.security==high`
		// `engine.labels`      | Docker Engine's labels         | `engine.labels.operatingsystem==ubuntu-14.04`
		//
		// `engine.labels` apply to Docker Engine labels like operating system,
		// drivers, etc. Swarm administrators add `node.labels` for operational
		// purposes by using the [`node update endpoint`](#operation/NodeUpdate).
		Constraints []string `json:"Constraints,omitempty"`

		// Maximum number of replicas for per node (default value is 0, which
		// is unlimited)
		MaxReplicas *int64 `json:"MaxReplicas,omitempty"`

		// Platforms stores all the platforms that the service's image can
		// run on. This field is used in the platform filter for scheduling.
		// If empty, then the platform filter is off, meaning there are no
		// scheduling restrictions.
		Platforms []Platform `json:"Platforms,omitempty"`

		// Preferences provide a way to make the scheduler aware of factors
		// such as topology. They are provided in order from highest to
		// lowest precedence.
		Preferences []struct {
			Spread *struct {
				// label descriptor, such as `engine.labels.az`.
				SpreadDescriptor *string `json:"SpreadDescriptor,omitempty"`
			} `json:"Spread,omitempty"`
		} `json:"Preferences,omitempty"`
	} `json:"Placement,omitempty"`

	// Plugin spec for the service.  *(Experimental release only.)*
	//
	// <p><br /></p>
	//
	// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
	// > mutually exclusive. PluginSpec is only used when the Runtime field
	// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
	// > field is set to `attachment`.
	PluginSpec *struct {
		// Disable the plugin once scheduled.
		Disabled *bool `json:"Disabled,omitempty"`

		// The name or 'alias' to use for the plugin.
		Name            *string           `json:"Name,omitempty"`
		PluginPrivilege []PluginPrivilege `json:"PluginPrivilege,omitempty"`

		// The plugin image reference to use.
		Remote *string `json:"Remote,omitempty"`
	} `json:"PluginSpec,omitempty"`

	// Resource requirements which apply to each individual container created
	// as part of the service.
	Resources *struct {
		// An object describing a limit on resources which can be requested by a task.
		Limits *Limit `json:"Limits,omitempty"`

		// An object describing the resources which can be advertised by a node and
		// requested by a task.
		Reservations *ResourceObject `json:"Reservations,omitempty"`
	} `json:"Resources,omitempty"`

	// Specification for the restart policy which applies to containers
	// created as part of this service.
	RestartPolicy *struct {
		// Condition for restart.
		Condition *TaskSpecRestartPolicyCondition `json:"Condition,omitempty"`

		// Delay between restart attempts.
		Delay *int64 `json:"Delay,omitempty"`

		// Maximum attempts to restart a given container before giving up
		// (default value is 0, which is ignored).
		MaxAttempts *int64 `json:"MaxAttempts,omitempty"`

		// Windows is the time window used to evaluate the restart policy
		// (default value is 0, which is unbounded).
		Window *int64 `json:"Window,omitempty"`
	} `json:"RestartPolicy,omitempty"`

	// Runtime is the type of runtime specified for the task executor.
	Runtime *string `json:"Runtime,omitempty"`
}

// TaskSpec_LogDriver_Options defines model for TaskSpec.LogDriver.Options.
type TaskSpec_LogDriver_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Container spec for the service.
//
// <p><br /></p>
//
// > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
// > mutually exclusive. PluginSpec is only used when the Runtime field
// > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
// > field is set to `attachment`.
type TaskSpecContainerSpec struct {
	// Arguments to the command.
	Args []string `json:"Args,omitempty"`

	// A list of kernel capabilities to add to the default set
	// for the container.
	CapabilityAdd []string `json:"CapabilityAdd,omitempty"`

	// A list of kernel capabilities to drop from the default set
	// for the container.
	CapabilityDrop []string `json:"CapabilityDrop,omitempty"`

	// The command to be run in the image.
	Command []string `json:"Command,omitempty"`

	// Configs contains references to zero or more configs that will be
	// exposed to the service.
	Configs []TaskSpecContainerSpecConfig `json:"Configs,omitempty"`

	// Specification for DNS related configurations in resolver configuration
	// file (`resolv.conf`).
	DNSConfig *struct {
		// The IP addresses of the name servers.
		Nameservers []string `json:"Nameservers,omitempty"`

		// A list of internal resolver variables to be modified (e.g.,
		// `debug`, `ndots:3`, etc.).
		Options []string `json:"Options,omitempty"`

		// A search list for host-name lookup.
		Search []string `json:"Search,omitempty"`
	} `json:"DNSConfig,omitempty"`

	// The working directory for commands to run in.
	Dir *string `json:"Dir,omitempty"`

	// A list of environment variables in the form `VAR=value`.
	Env []string `json:"Env,omitempty"`

	// A list of additional groups that the container process will run as.
	Groups []string `json:"Groups,omitempty"`

	// A test to perform to check that the container is healthy.
	HealthCheck *HealthConfig `json:"HealthCheck,omitempty"`

	// The hostname to use for the container, as a valid
	// [RFC 1123](https://tools.ietf.org/html/rfc1123) hostname.
	Hostname *string `json:"Hostname,omitempty"`

	// A list of hostname/IP mappings to add to the container's `hosts`
	// file. The format of extra hosts is specified in the
	// [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)
	// man page:
	//
	//     IP_address canonical_hostname [aliases...]
	Hosts []string `json:"Hosts,omitempty"`

	// The image name to use for the container
	Image *string `json:"Image,omitempty"`

	// Run an init inside the container that forwards signals and reaps
	// processes. This field is omitted if empty, and the default (as
	// configured on the daemon) is used.
	Init *bool `json:"Init,omitempty"`

	// Isolation technology of the containers running the service.
	// (Windows only)
	Isolation *TaskSpecContainerSpecIsolation `json:"Isolation,omitempty"`

	// User-defined key/value data.
	Labels *TaskSpecContainerSpec_Labels `json:"Labels,omitempty"`

	// Specification for mounts to be added to containers created as part
	// of the service.
	Mounts []Mount `json:"Mounts,omitempty"`

	// Open `stdin`
	OpenStdin *bool `json:"OpenStdin,omitempty"`

	// Security options for the container
	Privileges *struct {
		// CredentialSpec for managed service account (Windows only)
		CredentialSpec *struct {
			// Load credential spec from a Swarm Config with the given ID.
			// The specified config must also be present in the Configs
			// field with the Runtime property set.
			//
			// <p><br /></p>
			//
			//
			// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
			// > and `CredentialSpec.Config` are mutually exclusive.
			Config *string `json:"Config,omitempty"`

			// Load credential spec from this file. The file is read by
			// the daemon, and must be present in the `CredentialSpecs`
			// subdirectory in the docker data directory, which defaults
			// to `C:\ProgramData\Docker\` on Windows.
			//
			// For example, specifying `spec.json` loads
			// `C:\ProgramData\Docker\CredentialSpecs\spec.json`.
			//
			// <p><br /></p>
			//
			// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
			// > and `CredentialSpec.Config` are mutually exclusive.
			File *string `json:"File,omitempty"`

			// Load credential spec from this value in the Windows
			// registry. The specified registry value must be located in:
			//
			// `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs`
			//
			// <p><br /></p>
			//
			//
			// > **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
			// > and `CredentialSpec.Config` are mutually exclusive.
			Registry *string `json:"Registry,omitempty"`
		} `json:"CredentialSpec,omitempty"`

		// SELinux labels of the container
		SELinuxContext *struct {
			// Disable SELinux
			Disable *bool `json:"Disable,omitempty"`

			// SELinux level label
			Level *string `json:"Level,omitempty"`

			// SELinux role label
			Role *string `json:"Role,omitempty"`

			// SELinux type label
			Type *string `json:"Type,omitempty"`

			// SELinux user label
			User *string `json:"User,omitempty"`
		} `json:"SELinuxContext,omitempty"`
	} `json:"Privileges,omitempty"`

	// Mount the container's root filesystem as read only.
	ReadOnly *bool `json:"ReadOnly,omitempty"`

	// Secrets contains references to zero or more secrets that will be
	// exposed to the service.
	Secrets []TaskSpecContainerSpecSecret `json:"Secrets,omitempty"`

	// Amount of time to wait for the container to terminate before
	// forcefully killing it.
	StopGracePeriod *int64 `json:"StopGracePeriod,omitempty"`

	// Signal to stop the container.
	StopSignal *string `json:"StopSignal,omitempty"`

	// Set kernel namedspaced parameters (sysctls) in the container.
	// The Sysctls option on services accepts the same sysctls as the
	// are supported on containers. Note that while the same sysctls are
	// supported, no guarantees or checks are made about their
	// suitability for a clustered environment, and it's up to the user
	// to determine whether a given sysctl will work properly in a
	// Service.
	Sysctls *TaskSpecContainerSpec_Sysctls `json:"Sysctls,omitempty"`

	// Whether a pseudo-TTY should be allocated.
	TTY *bool `json:"TTY,omitempty"`

	// A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
	Ulimits []struct {
		// Hard limit
		Hard *int `json:"Hard,omitempty"`

		// Name of ulimit
		Name *string `json:"Name,omitempty"`

		// Soft limit
		Soft *int `json:"Soft,omitempty"`
	} `json:"Ulimits,omitempty"`

	// The user inside the container.
	User *string `json:"User,omitempty"`
}

// User-defined key/value data.
type TaskSpecContainerSpec_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Set kernel namedspaced parameters (sysctls) in the container.
// The Sysctls option on services accepts the same sysctls as the
// are supported on containers. Note that while the same sysctls are
// supported, no guarantees or checks are made about their
// suitability for a clustered environment, and it's up to the user
// to determine whether a given sysctl will work properly in a
// Service.
type TaskSpecContainerSpec_Sysctls struct {
	AdditionalProperties map[string]string `json:"-"`
}

// TaskSpecContainerSpecConfig defines model for TaskSpecContainerSpecConfig.
type TaskSpecContainerSpecConfig struct {
	// ConfigID represents the ID of the specific config that we're
	// referencing.
	ConfigID *string `json:"ConfigID,omitempty"`

	// ConfigName is the name of the config that this references,
	// but this is just provided for lookup/display purposes. The
	// config in the reference will be identified by its ID.
	ConfigName *string `json:"ConfigName,omitempty"`

	// File represents a specific target that is backed by a file.
	//
	// <p><br /><p>
	//
	// > **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive
	File *struct {
		// GID represents the file GID.
		GID *string `json:"GID,omitempty"`

		// Mode represents the FileMode of the file.
		Mode *uint32 `json:"Mode,omitempty"`

		// Name represents the final filename in the filesystem.
		Name *string `json:"Name,omitempty"`

		// UID represents the file UID.
		UID *string `json:"UID,omitempty"`
	} `json:"File,omitempty"`

	// Runtime represents a target that is not mounted into the
	// container but is used by the task
	//
	// <p><br /><p>
	//
	// > **Note**: `Configs.File` and `Configs.Runtime` are mutually
	// > exclusive
	Runtime *map[string]interface{} `json:"Runtime,omitempty"`
}

// TaskSpecContainerSpecSecret defines model for TaskSpecContainerSpecSecret.
type TaskSpecContainerSpecSecret struct {
	// File represents a specific target that is backed by a file.
	File *struct {
		// GID represents the file GID.
		GID *string `json:"GID,omitempty"`

		// Mode represents the FileMode of the file.
		Mode *uint32 `json:"Mode,omitempty"`

		// Name represents the final filename in the filesystem.
		Name *string `json:"Name,omitempty"`

		// UID represents the file UID.
		UID *string `json:"UID,omitempty"`
	} `json:"File,omitempty"`

	// SecretID represents the ID of the specific secret that we're
	// referencing.
	SecretID *string `json:"SecretID,omitempty"`

	// SecretName is the name of the secret that this references,
	// but this is just provided for lookup/display purposes. The
	// secret in the reference will be identified by its ID.
	SecretName *string `json:"SecretName,omitempty"`
}

// ThrottleDevice defines model for ThrottleDevice.
type ThrottleDevice struct {
	// Device path
	Path *string `json:"Path,omitempty"`

	// Rate
	Rate *int64 `json:"Rate,omitempty"`
}

// Volume defines model for Volume.
type Volume struct {
	// Date/Time the volume was created.
	CreatedAt *string `json:"CreatedAt,omitempty"`

	// Name of the volume driver used by the volume.
	Driver string `json:"Driver"`

	// User-defined key/value metadata.
	Labels Volume_Labels `json:"Labels"`

	// Mount path of the volume on the host.
	Mountpoint string `json:"Mountpoint"`

	// Name of the volume.
	Name string `json:"Name"`

	// The driver specific options used when creating the volume.
	Options Volume_Options `json:"Options"`

	// The level at which the volume exists. Either `global` for cluster-wide,
	// or `local` for machine level.
	Scope VolumeScope `json:"Scope"`

	// Low-level details about the volume, provided by the volume driver.
	// Details are returned as a map with key/value pairs:
	// `{"key":"value","key2":"value2"}`.
	//
	// The `Status` field is optional, and is omitted if the volume driver
	// does not support this feature.
	Status *Volume_Status `json:"Status,omitempty"`

	// Usage details about the volume. This information is used by the
	// `GET /system/df` endpoint, and omitted in other endpoints.
	UsageData *struct {
		// The number of containers referencing this volume. This field
		// is set to `-1` if the reference-count is not available.
		RefCount int `json:"RefCount"`

		// Amount of disk space used by the volume (in bytes). This information
		// is only available for volumes created with the `"local"` volume
		// driver. For volumes created with other volume drivers, this field
		// is set to `-1` ("not available")
		Size int `json:"Size"`
	} `json:"UsageData,omitempty"`
}

// User-defined key/value metadata.
type Volume_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// The driver specific options used when creating the volume.
type Volume_Options struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Low-level details about the volume, provided by the volume driver.
// Details are returned as a map with key/value pairs:
// `{"key":"value","key2":"value2"}`.
//
// The `Status` field is optional, and is omitted if the volume driver
// does not support this feature.
type Volume_Status struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Volume configuration
type VolumeCreateOptions struct {
	// Name of the volume driver to use.
	Driver *string `json:"Driver,omitempty"`

	// A mapping of driver options and values. These options are
	// passed directly to the driver and are driver specific.
	DriverOpts *VolumeCreateOptions_DriverOpts `json:"DriverOpts,omitempty"`

	// User-defined key/value metadata.
	Labels *VolumeCreateOptions_Labels `json:"Labels,omitempty"`

	// The new volume's name. If not specified, Docker generates a name.
	Name *string `json:"Name,omitempty"`
}

// A mapping of driver options and values. These options are
// passed directly to the driver and are driver specific.
type VolumeCreateOptions_DriverOpts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// User-defined key/value metadata.
type VolumeCreateOptions_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// IoK8sAPICoreV1ObjectReference defines model for io.k8s.api.core.v1.ObjectReference.
type IoK8sAPICoreV1ObjectReference struct {
	APIVersion      *string `json:"apiVersion,omitempty"`
	FieldPath       *string `json:"fieldPath,omitempty"`
	Kind            *string `json:"kind,omitempty"`
	Name            *string `json:"name,omitempty"`
	Namespace       *string `json:"namespace,omitempty"`
	ResourceVersion *string `json:"resourceVersion,omitempty"`
	UID             *string `json:"uid,omitempty"`
}

// APIGroup contains the name, the supported versions, and the preferred version of a group.
type IoK8sApimachineryPkgApisMetaV1APIGroup struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	APIVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// name is the name of the group.
	Name string `json:"name"`

	// GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility.
	PreferredVersion *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery `json:"preferredVersion,omitempty"`

	// a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
	ServerAddressByClientCIDRs []IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR `json:"serverAddressByClientCIDRs,omitempty"`

	// versions are the versions supported in this group.
	Versions []IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery `json:"versions"`
}

// APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
type IoK8sApimachineryPkgApisMetaV1APIGroupList struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	APIVersion *string `json:"apiVersion,omitempty"`

	// groups is a list of APIGroup.
	Groups []IoK8sApimachineryPkgApisMetaV1APIGroup `json:"groups"`

	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`
}

// APIResource specifies the name of a resource and whether it is namespaced.
type IoK8sApimachineryPkgApisMetaV1APIResource struct {
	// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
	Categories []string `json:"categories,omitempty"`

	// group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale".
	Group *string `json:"group,omitempty"`

	// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
	Kind string `json:"kind"`

	// name is the plural name of the resource.
	Name string `json:"name"`

	// namespaced indicates if a resource is namespaced or not.
	Namespaced bool `json:"namespaced"`

	// shortNames is a list of suggested short names of the resource.
	ShortNames []string `json:"shortNames,omitempty"`

	// singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface.
	SingularName string `json:"singularName"`

	// The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.
	StorageVersionHash *string `json:"storageVersionHash,omitempty"`

	// verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy)
	Verbs []string `json:"verbs"`

	// version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
	Version *string `json:"version,omitempty"`
}

// APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.
type IoK8sApimachineryPkgApisMetaV1APIResourceList struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	APIVersion *string `json:"apiVersion,omitempty"`

	// groupVersion is the group and version this APIResourceList is for.
	GroupVersion string `json:"groupVersion"`

	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// resources contains the name of the resources and if they are namespaced.
	Resources []IoK8sApimachineryPkgApisMetaV1APIResource `json:"resources"`
}

// APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API.
type IoK8sApimachineryPkgApisMetaV1APIVersions struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	APIVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
	ServerAddressByClientCIDRs []IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR `json:"serverAddressByClientCIDRs"`

	// versions are the api versions that are available.
	Versions []string `json:"versions"`
}

// FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
//
// Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.
//
// The exact format is defined in sigs.k8s.io/structured-merge-diff
type IoK8sApimachineryPkgApisMetaV1FieldsV1 map[string]interface{}

// GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility.
type IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery struct {
	// groupVersion specifies the API group and version in the form "group/version"
	GroupVersion string `json:"groupVersion"`

	// version specifies the version in the form of "version". This is to save the clients the trouble of splitting the GroupVersion.
	Version string `json:"version"`
}

// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
type IoK8sApimachineryPkgApisMetaV1ListMeta struct {
	// continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
	Continue *string `json:"continue,omitempty"`

	// remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
	RemainingItemCount *int64 `json:"remainingItemCount,omitempty"`

	// String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	SelfLink *string `json:"selfLink,omitempty"`
}

// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
type IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry struct {
	// APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
	APIVersion *string `json:"apiVersion,omitempty"`

	// FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
	FieldsType *string `json:"fieldsType,omitempty"`

	// FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
	//
	// Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.
	//
	// The exact format is defined in sigs.k8s.io/structured-merge-diff
	FieldsV1 *IoK8sApimachineryPkgApisMetaV1FieldsV1 `json:"fieldsV1,omitempty"`

	// Manager is an identifier of the workflow managing these fields.
	Manager *string `json:"manager,omitempty"`

	// Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
	Operation *string `json:"operation,omitempty"`

	// Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
	Subresource *string `json:"subresource,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	Time *IoK8sApimachineryPkgApisMetaV1Time `json:"time,omitempty"`
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
type IoK8sApimachineryPkgApisMetaV1ObjectMeta struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
	Annotations *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations `json:"annotations,omitempty"`

	// Deprecated: ClusterName is a legacy field that was always cleared by the system and never used; it will be removed completely in 1.25.
	//
	// The name in the go struct is changed to help clients detect accidental use.
	ClusterName *string `json:"clusterName,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	CreationTimestamp *IoK8sApimachineryPkgApisMetaV1Time `json:"creationTimestamp,omitempty"`

	// Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	DeletionTimestamp *IoK8sApimachineryPkgApisMetaV1Time `json:"deletionTimestamp,omitempty"`

	// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
	Finalizers []string `json:"finalizers,omitempty"`

	// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
	//
	// If this field is specified and the generated name exists, the server will return a 409.
	//
	// Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
	GenerateName *string `json:"generateName,omitempty"`

	// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
	Generation *int64 `json:"generation,omitempty"`

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
	Labels *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels `json:"labels,omitempty"`

	// ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
	ManagedFields []IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry `json:"managedFields,omitempty"`

	// Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name *string `json:"name,omitempty"`

	// Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
	//
	// Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
	Namespace *string `json:"namespace,omitempty"`

	// List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
	OwnerReferences []IoK8sApimachineryPkgApisMetaV1OwnerReference `json:"ownerReferences,omitempty"`

	// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	SelfLink *string `json:"selfLink,omitempty"`

	// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
	//
	// Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	UID *string `json:"uid,omitempty"`
}

// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
type IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
type IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
type IoK8sApimachineryPkgApisMetaV1OwnerReference struct {
	// API version of the referent.
	APIVersion string `json:"apiVersion"`

	// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
	BlockOwnerDeletion *bool `json:"blockOwnerDeletion,omitempty"`

	// If true, this reference points to the managing controller.
	Controller *bool `json:"controller,omitempty"`

	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind string `json:"kind"`

	// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name string `json:"name"`

	// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	UID string `json:"uid"`
}

// ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
type IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR struct {
	// The CIDR with which clients can match their IP to figure out the server address that they should use.
	ClientCIDR string `json:"clientCIDR"`

	// Address of this server, suitable for a client that matches the above CIDR. This can be a hostname, hostname:port, IP or IP:port.
	ServerAddress string `json:"serverAddress"`
}

// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
type IoK8sApimachineryPkgApisMetaV1Time time.Time

// IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
type IoK8sApimachineryPkgUtilIntstrIntOrString string

// K8sCertificateSigningRequest defines model for k8s.CertificateSigningRequest.
type K8sCertificateSigningRequest struct {
	APIVersion                              string `json:"apiVersion"`
	AutomountCertificateSigningRequestToken *bool  `json:"automountCertificateSigningRequestToken,omitempty"`
	Kind                                    string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sCertificateSigningRequestSpec         `json:"spec"`
	Status   K8sCertificateSigningRequestStatus       `json:"status"`
}

// K8sCertificateSigningRequestCondition defines model for k8s.CertificateSigningRequestCondition.
type K8sCertificateSigningRequestCondition struct {
	// True, False, Unknown
	Status string `json:"status"`

	// Approved, Denied, Failed
	Type string `json:"type"`
}

// K8sCertificateSigningRequestList defines model for k8s.CertificateSigningRequestList.
type K8sCertificateSigningRequestList struct {
	APIVersion string                         `json:"apiVersion"`
	Items      []K8sCertificateSigningRequest `json:"items"`
	Kind       string                         `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sCertificateSigningRequestSpec defines model for k8s.CertificateSigningRequestSpec.
type K8sCertificateSigningRequestSpec struct {
	ExpirationSeconds *int     `json:"expirationSeconds,omitempty"`
	Request           []byte   `json:"request"`
	SignerName        string   `json:"signerName"`
	UID               *string  `json:"uid,omitempty"`
	Usages            []string `json:"usages,omitempty"`
	Username          *string  `json:"username,omitempty"`
}

// K8sCertificateSigningRequestStatus defines model for k8s.CertificateSigningRequestStatus.
type K8sCertificateSigningRequestStatus struct {
	Certificate []byte                                  `json:"certificate,omitempty"`
	Conditions  []K8sCertificateSigningRequestCondition `json:"conditions,omitempty"`
}

// K8sConfigMap defines model for k8s.ConfigMap.
type K8sConfigMap struct {
	APIVersion string                   `json:"apiVersion"`
	BinaryData *K8sConfigMap_BinaryData `json:"binaryData,omitempty"`
	Data       *K8sConfigMap_Data       `json:"data,omitempty"`
	Kind       string                   `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
}

// K8sConfigMap_BinaryData defines model for K8sConfigMap.BinaryData.
type K8sConfigMap_BinaryData struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sConfigMap_Data defines model for K8sConfigMap.Data.
type K8sConfigMap_Data struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sConfigMapList defines model for k8s.ConfigMapList.
type K8sConfigMapList struct {
	APIVersion string         `json:"apiVersion"`
	Items      []K8sConfigMap `json:"items"`
	Kind       string         `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// A single application container that you want to run within a pod.
type K8sContainer struct {
	// Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Args []string `json:"args,omitempty"`

	// Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Command []string `json:"command,omitempty"`

	// List of environment variables to set in the container. Cannot be updated.
	Env []K8sEnvVar `json:"env,omitempty"`

	// Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
	Image *string `json:"image,omitempty"`

	// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	//
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty"`

	// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
	Name string `json:"name"`

	// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
	Ports     []K8sContainerPort       `json:"ports,omitempty"`
	Resources *K8sResourceRequirements `json:"resources,omitempty"`

	// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
	Stdin *bool `json:"stdin,omitempty"`

	// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
	StdinOnce *bool `json:"stdinOnce,omitempty"`

	// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
	TerminationMessagePath *string `json:"terminationMessagePath,omitempty"`

	// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
	//
	TerminationMessagePolicy *string `json:"terminationMessagePolicy,omitempty"`

	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
	Tty *bool `json:"tty,omitempty"`

	// volumeDevices is the list of block devices to be used by the container.
	VolumeDevices []K8sVolumeDevice `json:"volumeDevices,omitempty"`

	// Pod volumes to mount into the container's filesystem. Cannot be updated.
	VolumeMounts []K8sVolumeMount `json:"volumeMounts,omitempty"`

	// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
	WorkingDir *string `json:"workingDir,omitempty"`
}

// ContainerPort represents a network port in a single container.
type K8sContainerPort struct {
	// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
	ContainerPort int32 `json:"containerPort"`

	// What host IP to bind the external port to.
	HostIP *string `json:"hostIP,omitempty"`

	// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
	HostPort *int32 `json:"hostPort,omitempty"`

	// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
	Name *string `json:"name,omitempty"`

	// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
	//
	Protocol *string `json:"protocol,omitempty"`
}

// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
type K8sContainerState struct {
	// ContainerStateRunning is a running state of a container.
	Running *K8sContainerStateRunning `json:"running,omitempty"`

	// ContainerStateTerminated is a terminated state of a container.
	Terminated *K8sContainerStateTerminated `json:"terminated,omitempty"`

	// ContainerStateWaiting is a waiting state of a container.
	Waiting *K8sContainerStateWaiting `json:"waiting,omitempty"`
}

// ContainerStateRunning is a running state of a container.
type K8sContainerStateRunning struct {
	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	StartedAt *IoK8sApimachineryPkgApisMetaV1Time `json:"startedAt,omitempty"`
}

// ContainerStateTerminated is a terminated state of a container.
type K8sContainerStateTerminated struct {
	// Container's ID in the format '<type>://<container_id>'
	ContainerID *string `json:"containerID,omitempty"`

	// Exit status from the last termination of the container
	ExitCode int32 `json:"exitCode"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	FinishedAt *IoK8sApimachineryPkgApisMetaV1Time `json:"finishedAt,omitempty"`

	// Message regarding the last termination of the container
	Message *string `json:"message,omitempty"`

	// (brief) reason from the last termination of the container
	Reason *string `json:"reason,omitempty"`

	// Signal from the last termination of the container
	Signal *int32 `json:"signal,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	StartedAt *IoK8sApimachineryPkgApisMetaV1Time `json:"startedAt,omitempty"`
}

// ContainerStateWaiting is a waiting state of a container.
type K8sContainerStateWaiting struct {
	// Message regarding why the container is not yet running.
	Message *string `json:"message,omitempty"`

	// (brief) reason the container is not yet running.
	Reason *string `json:"reason,omitempty"`
}

// ContainerStatus contains details for the current status of this container.
type K8sContainerStatus struct {
	// Container's ID in the format '<type>://<container_id>'.
	ContainerID *string `json:"containerID,omitempty"`

	// The image the container is running. More info: https://kubernetes.io/docs/concepts/containers/images.
	Image string `json:"image"`

	// ImageID of the container's image.
	ImageID string `json:"imageID"`

	// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
	LastState *K8sContainerState `json:"lastState,omitempty"`

	// This must be a DNS_LABEL. Each container in a pod must have a unique name. Cannot be updated.
	Name string `json:"name"`

	// Specifies whether the container has passed its readiness probe.
	Ready bool `json:"ready"`

	// The number of times the container has been restarted.
	RestartCount int32 `json:"restartCount"`

	// Specifies whether the container has passed its startup probe. Initialized as false, becomes true after startupProbe is considered successful. Resets to false when the container is restarted, or if kubelet loses state temporarily. Is always true when no startupProbe is defined.
	Started *bool `json:"started,omitempty"`

	// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
	State *K8sContainerState `json:"state,omitempty"`
}

// K8sDeployment defines model for k8s.Deployment.
type K8sDeployment struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sDeploymentSpec                        `json:"spec"`
	Status   K8sDeploymentStatus                      `json:"status"`
}

// K8sDeploymentCondition defines model for k8s.DeploymentCondition.
type K8sDeploymentCondition struct {
	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	LastTransitionTime *IoK8sApimachineryPkgApisMetaV1Time `json:"lastTransitionTime,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	LastUpdateTime *IoK8sApimachineryPkgApisMetaV1Time `json:"lastUpdateTime,omitempty"`
	Message        *string                             `json:"message,omitempty"`
	Reason         *string                             `json:"reason,omitempty"`
	Status         string                              `json:"status"`
	Type           string                              `json:"type"`
}

// K8sDeploymentList defines model for k8s.DeploymentList.
type K8sDeploymentList struct {
	APIVersion string          `json:"apiVersion"`
	Items      []K8sDeployment `json:"items"`
	Kind       string          `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sDeploymentSpec defines model for k8s.DeploymentSpec.
type K8sDeploymentSpec struct {
	MinReadySeconds         int32  `json:"minReadySeconds"`
	Paused                  *bool  `json:"paused,omitempty"`
	ProgressDeadlineSeconds *int32 `json:"progressDeadlineSeconds,omitempty"`
	Replicas                int    `json:"replicas"`
	RevisionHistoryLimit    *int32 `json:"revisionHistoryLimit,omitempty"`

	// ignored for compatbility. the deployment controller selects the pods it creates
	Selector K8sDeploymentSpec_Selector `json:"selector"`
	Strategy K8sDeploymentStrategy      `json:"strategy"`

	// Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
	Template *K8sPod `json:"template,omitempty"`
}

// ignored for compatbility. the deployment controller selects the pods it creates
type K8sDeploymentSpec_Selector struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sDeploymentStatus defines model for k8s.DeploymentStatus.
type K8sDeploymentStatus struct {
	AvailableReplicas   int                      `json:"availableReplicas"`
	CollisionCount      int                      `json:"collisionCount"`
	Conditions          []K8sDeploymentCondition `json:"conditions"`
	ObservedGeneration  int64                    `json:"observedGeneration"`
	ReadyReplicas       int32                    `json:"readyReplicas"`
	Replicas            int32                    `json:"replicas"`
	UnavailableReplicas int32                    `json:"unavailableReplicas"`
	UpdatedReplicas     int32                    `json:"updatedReplicas"`
}

// K8sDeploymentStrategy defines model for k8s.DeploymentStrategy.
type K8sDeploymentStrategy struct {
	RollingUpdate *K8sRollingUpdateDeployment `json:"rollingUpdate,omitempty"`

	// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
	//
	Type string `json:"type"`
}

// K8sEndpointAddress defines model for k8s.EndpointAddress.
type K8sEndpointAddress struct {
	Hostname  *string                        `json:"hostname,omitempty"`
	IP        string                         `json:"ip"`
	NodeName  *string                        `json:"nodeName,omitempty"`
	TargetRef *IoK8sAPICoreV1ObjectReference `json:"targetRef,omitempty"`
}

// K8sEndpointPort defines model for k8s.EndpointPort.
type K8sEndpointPort struct {
	AppProtocol *string `json:"appProtocol,omitempty"`
	Name        *string `json:"name,omitempty"`
	Port        int32   `json:"port"`

	// TCP|UDP
	Protocol *string `json:"protocol,omitempty"`
}

// K8sEndpointSubset defines model for k8s.EndpointSubset.
type K8sEndpointSubset struct {
	Addresses         []K8sEndpointAddress `json:"addresses,omitempty"`
	NotReadyAddresses []K8sEndpointAddress `json:"notReadyAddresses,omitempty"`
	Ports             []K8sEndpointPort    `json:"ports,omitempty"`
}

// K8sEndpoints defines model for k8s.Endpoints.
type K8sEndpoints struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
	Subsets  []K8sEndpointSubset                       `json:"subsets,omitempty"`
}

// K8sEndpointsList defines model for k8s.EndpointsList.
type K8sEndpointsList struct {
	APIVersion *string        `json:"apiVersion,omitempty"`
	Items      []K8sEndpoints `json:"items"`
	Kind       *string        `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// EnvVar represents an environment variable present in a Container.
type K8sEnvVar struct {
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name string `json:"name"`

	// Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
	Value *string `json:"value,omitempty"`
}

// K8sEvent defines model for k8s.Event.
type K8sEvent struct {
	Action     *string    `json:"action,omitempty"`
	APIVersion []K8sEvent `json:"apiVersion,omitempty"`
	EventTime  *time.Time `json:"eventTime,omitempty"`
	Kind       *string    `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata            *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
	Note                *string                                 `json:"note,omitempty"`
	Reason              *string                                 `json:"reason,omitempty"`
	Regarding           *IoK8sAPICoreV1ObjectReference          `json:"regarding,omitempty"`
	Related             *IoK8sAPICoreV1ObjectReference          `json:"related,omitempty"`
	ReportingController *string                                 `json:"reportingController,omitempty"`
	ReportingInstance   *string                                 `json:"reportingInstance,omitempty"`
	Type                *string                                 `json:"type,omitempty"`
}

// K8sEventList defines model for k8s.EventList.
type K8sEventList struct {
	APIVersion *string    `json:"apiVersion,omitempty"`
	Items      []K8sEvent `json:"items"`
	Kind       *string    `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sIngress defines model for k8s.Ingress.
type K8sIngress struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sIngressSpec                           `json:"spec"`
	Status   K8sIngressStatus                         `json:"status"`
}

// K8sIngressClass defines model for k8s.IngressClass.
type K8sIngressClass struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sIngressClassSpec                      `json:"spec"`
}

// K8sIngressClassList defines model for k8s.IngressClassList.
type K8sIngressClassList struct {
	APIVersion string            `json:"apiVersion"`
	Items      []K8sIngressClass `json:"items"`
	Kind       string            `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sIngressClassSpec defines model for k8s.IngressClassSpec.
type K8sIngressClassSpec struct {
	Controller *string `json:"controller,omitempty"`
}

// K8sIngressList defines model for k8s.IngressList.
type K8sIngressList struct {
	APIVersion string       `json:"apiVersion"`
	Items      []K8sIngress `json:"items"`
	Kind       string       `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sIngressRule defines model for k8s.IngressRule.
type K8sIngressRule struct {
	Host *string             `json:"host,omitempty"`
	HTTP *K8sIngressRuleHTTP `json:"http,omitempty"`
}

// K8sIngressRuleHTTP defines model for k8s.IngressRuleHttp.
type K8sIngressRuleHTTP struct {
	Paths []K8sIngressRuleHTTPPath `json:"paths,omitempty"`
}

// K8sIngressRuleHTTPPath defines model for k8s.IngressRuleHttpPath.
type K8sIngressRuleHTTPPath struct {
	Backend  *K8sIngressRuleHTTPPathBackend `json:"backend,omitempty"`
	Path     *string                        `json:"path,omitempty"`
	PathType *string                        `json:"pathType,omitempty"`
}

// K8sIngressRuleHTTPPathBackend defines model for k8s.IngressRuleHttpPathBackend.
type K8sIngressRuleHTTPPathBackend struct {
	Service *K8sIngressRuleHTTPPathBackendService `json:"service,omitempty"`
}

// K8sIngressRuleHTTPPathBackendService defines model for k8s.IngressRuleHttpPathBackendService.
type K8sIngressRuleHTTPPathBackendService struct {
	Name *string                                   `json:"name,omitempty"`
	Port *K8sIngressRuleHTTPPathBackendServicePort `json:"port,omitempty"`
}

// K8sIngressRuleHTTPPathBackendServicePort defines model for k8s.IngressRuleHttpPathBackendServicePort.
type K8sIngressRuleHTTPPathBackendServicePort struct {
	Number *int `json:"number,omitempty"`
}

// K8sIngressSpec defines model for k8s.IngressSpec.
type K8sIngressSpec struct {
	DefaultBackend   *K8sIngressRuleHTTPPathBackend `json:"defaultBackend,omitempty"`
	IngressClassName *string                        `json:"ingressClassName,omitempty"`
	Rules            []K8sIngressRule               `json:"rules,omitempty"`
	TLS              []K8sIngressTLS                `json:"tls,omitempty"`
}

// K8sIngressStatus defines model for k8s.IngressStatus.
type K8sIngressStatus struct {
	LoadBalancer *K8sLoadBalancerStatus `json:"loadBalancer,omitempty"`
}

// K8sIngressTLS defines model for k8s.IngressTLS.
type K8sIngressTLS struct {
	Hosts []string `json:"hosts,omitempty"`
}

// K8sLoadBalancerStatus defines model for k8s.LoadBalancerStatus.
type K8sLoadBalancerStatus struct {
	Ingress []K8sLoadBalancerStatusIngress `json:"ingress,omitempty"`
}

// K8sLoadBalancerStatusIngress defines model for k8s.LoadBalancerStatusIngress.
type K8sLoadBalancerStatusIngress struct {
	Hostname *string                            `json:"hostname,omitempty"`
	IP       *string                            `json:"ip,omitempty"`
	Ports    []K8sLoadBalancerStatusIngressPort `json:"ports,omitempty"`
}

// K8sLoadBalancerStatusIngressPort defines model for k8s.LoadBalancerStatusIngressPort.
type K8sLoadBalancerStatusIngressPort struct {
	Error    *string `json:"error,omitempty"`
	Port     *int32  `json:"port,omitempty"`
	Protocol *string `json:"protocol,omitempty"`
}

// Namespace
type K8sNamespace struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sNamespaceSpec                         `json:"spec"`
	Status   K8sNamespaceStatus                       `json:"status"`
}

// NamespaceList is a list of Namespaces.
type K8sNamespaceList struct {
	APIVersion string         `json:"apiVersion"`
	Items      []K8sNamespace `json:"items"`
	Kind       string         `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sNamespaceSpec defines model for k8s.NamespaceSpec.
type K8sNamespaceSpec struct {
	Finalizers []string `json:"finalizers,omitempty"`
}

// K8sNamespaceStatus defines model for k8s.NamespaceStatus.
type K8sNamespaceStatus struct {
	Phase string `json:"phase"`
}

// Node is emulated to make helm work. Kraud does not have nodes.
type K8sNode struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
	Spec     *K8sNodeSpec                              `json:"spec,omitempty"`
	Status   *K8sNodeStatus                            `json:"status,omitempty"`
}

// K8sNodeAddress defines model for k8s.NodeAddress.
type K8sNodeAddress struct {
	Address string `json:"address"`
	Type    string `json:"type"`
}

// K8sNodeCondition defines model for k8s.NodeCondition.
type K8sNodeCondition struct {
	LastHeartbeatTime  time.Time `json:"lastHeartbeatTime"`
	LastTransitionTime time.Time `json:"lastTransitionTime"`
	Message            string    `json:"message"`
	Reason             string    `json:"reason"`
	Status             string    `json:"status"`
	Type               string    `json:"type"`
}

// NodeList is a list of Nodes.
type K8sNodeList struct {
	APIVersion string    `json:"apiVersion"`
	Items      []K8sNode `json:"items"`
	Kind       string    `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sNodeResourceList defines model for k8s.NodeResourceList.
type K8sNodeResourceList struct {
	CPU              string `json:"cpu"`
	EphemeralStorage string `json:"ephemeral-storage"`
	GpStorage        string `json:"gp-storage"`
	Hugepages1gi     string `json:"hugepages-1Gi"`
	Hugepages2mi     string `json:"hugepages-2Mi"`
	Memory           string `json:"memory"`
	Pods             string `json:"pods"`
	RedStorage       string `json:"red-storage"`
}

// K8sNodeSpec defines model for k8s.NodeSpec.
type K8sNodeSpec struct {
	PodCIDR  string   `json:"podCIDR"`
	PodCIDRs []string `json:"podCIDRs,omitempty"`
}

// K8sNodeStatus defines model for k8s.NodeStatus.
type K8sNodeStatus struct {
	Addresses       []K8sNodeAddress    `json:"addresses"`
	Allocatable     K8sNodeResourceList `json:"allocatable"`
	Capacity        K8sNodeResourceList `json:"capacity"`
	Conditions      []K8sNodeCondition  `json:"conditions"`
	DaemonEndpoints struct {
		KubeletEndpoint struct {
			Port int `json:"Port"`
		} `json:"kubeletEndpoint"`
	} `json:"daemonEndpoints"`
	Images   []K8sNodeStatusImage `json:"images"`
	NodeInfo *K8sNodeSystemInfo   `json:"nodeInfo,omitempty"`
}

// K8sNodeStatusImage defines model for k8s.NodeStatusImage.
type K8sNodeStatusImage map[string]interface{}

// K8sNodeSystemInfo defines model for k8s.NodeSystemInfo.
type K8sNodeSystemInfo struct {
	Architecture            string `json:"architecture"`
	BootID                  string `json:"bootID"`
	ContainerRuntimeVersion string `json:"containerRuntimeVersion"`
	KernelVersion           string `json:"kernelVersion"`
	KubeProxyVersion        string `json:"kubeProxyVersion"`
	KubeletVersion          string `json:"kubeletVersion"`
	MachineID               string `json:"machineID"`
	OperatingSystem         string `json:"operatingSystem"`
	OsImage                 string `json:"osImage"`
	SystemUUID              string `json:"systemUUID"`
}

// K8sPersistentVolumeClaim defines model for k8s.PersistentVolumeClaim.
type K8sPersistentVolumeClaim struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`
	Spec     K8sPersistentVolumeClaimSpec             `json:"spec"`
}

// K8sPersistentVolumeClaimList defines model for k8s.PersistentVolumeClaimList.
type K8sPersistentVolumeClaimList struct {
	APIVersion string                     `json:"apiVersion"`
	Items      []K8sPersistentVolumeClaim `json:"items"`
	Kind       string                     `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// K8sPersistentVolumeClaimSpec defines model for k8s.PersistentVolumeClaimSpec.
type K8sPersistentVolumeClaimSpec struct {
	AccessModes      []string                               `json:"accessModes,omitempty"`
	Resources        *K8sPersistentVolumeClaimSpecResources `json:"resources,omitempty"`
	StorageClassName *string                                `json:"storageClassName,omitempty"`
}

// K8sPersistentVolumeClaimSpecResources defines model for k8s.PersistentVolumeClaimSpecResources.
type K8sPersistentVolumeClaimSpecResources struct {
	Requests struct {
		Storage string `json:"storage"`
	} `json:"requests"`
}

// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
type K8sPersistentVolumeClaimVolumeSource struct {
	// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName string `json:"claimName"`

	// readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
type K8sPod struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata"`

	// PodSpec is a description of a pod.
	Spec K8sPodSpec `json:"spec"`

	// PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.
	Status *K8sPodStatus `json:"status,omitempty"`
}

// PodCondition contains details for the current condition of this pod.
type K8sPodCondition struct {
	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	LastProbeTime *IoK8sApimachineryPkgApisMetaV1Time `json:"lastProbeTime,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	LastTransitionTime *IoK8sApimachineryPkgApisMetaV1Time `json:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about last transition.
	Message *string `json:"message,omitempty"`

	// Unique, one-word, CamelCase reason for the condition's last transition.
	Reason *string `json:"reason,omitempty"`

	// Status is the status of the condition. Can be True, False, Unknown. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	Status string `json:"status"`

	// Type is the type of the condition. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	Type string `json:"type"`
}

// IP address information for entries in the (plural) PodIPs field. Each entry includes:
//
//	IP: An IP address allocated to the pod. Routable at least within the cluster.
type K8sPodIP struct {
	// ip is an IP address (IPv4 or IPv6) assigned to the pod
	IP *string `json:"ip,omitempty"`
}

// PodList is a list of Pods.
type K8sPodList struct {
	APIVersion string   `json:"apiVersion"`
	Items      []K8sPod `json:"items"`
	Kind       string   `json:"kind"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata"`
}

// PodSpec is a description of a pod.
type K8sPodSpec struct {
	Containers []K8sContainer `json:"containers"`
	Volumes    []K8sVolume    `json:"volumes,omitempty"`
}

// PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.
type K8sPodStatus struct {
	// Current service state of pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	Conditions []K8sPodCondition `json:"conditions,omitempty"`

	// The list has one entry per container in the manifest. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	ContainerStatuses []K8sContainerStatus `json:"containerStatuses,omitempty"`

	// Status for any ephemeral containers that have run in this pod. This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
	EphemeralContainerStatuses []K8sContainerStatus `json:"ephemeralContainerStatuses,omitempty"`

	// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
	HostIP *string `json:"hostIP,omitempty"`

	// The list has one entry per init container in the manifest. The most recent successful init container will have ready = true, the most recently started container will have startTime set. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	InitContainerStatuses []K8sContainerStatus `json:"initContainerStatuses,omitempty"`

	// A human readable message indicating details about why the pod is in this condition.
	Message *string `json:"message,omitempty"`

	// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be scheduled right away as preemption victims receive their graceful termination periods. This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to give the resources on this node to a higher priority pod that is created after preemption. As a result, this field may be different than PodSpec.nodeName when the pod is scheduled.
	NominatedNodeName *string `json:"nominatedNodeName,omitempty"`

	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod's status. There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while. Running: The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded: All containers in the pod have terminated in success, and will not be restarted. Failed: All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system. Unknown: For some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	//
	Phase *string `json:"phase,omitempty"`

	// IP address allocated to the pod. Routable at least within the cluster. Empty if not yet allocated.
	PodIP *string `json:"podIP,omitempty"`

	// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list is empty if no IPs have been allocated yet.
	PodIPS []K8sPodIP `json:"podIPs,omitempty"`

	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements See PodQOSClass type for available QOS classes More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
	//
	QosClass *string `json:"qosClass,omitempty"`

	// A brief CamelCase message indicating details about why the pod is in this state. e.g. 'Evicted'
	Reason *string `json:"reason,omitempty"`

	// Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
	StartTime *IoK8sApimachineryPkgApisMetaV1Time `json:"startTime,omitempty"`
}

// K8sResourceRequirements defines model for k8s.ResourceRequirements.
type K8sResourceRequirements struct {
	Limits   *K8sResourceRequirements_Limits   `json:"limits,omitempty"`
	Requests *K8sResourceRequirements_Requests `json:"requests,omitempty"`
}

// K8sResourceRequirements_Limits defines model for K8sResourceRequirements.Limits.
type K8sResourceRequirements_Limits struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sResourceRequirements_Requests defines model for K8sResourceRequirements.Requests.
type K8sResourceRequirements_Requests struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sRollingUpdateDeployment defines model for k8s.RollingUpdateDeployment.
type K8sRollingUpdateDeployment struct {
	MaxSurge       int `json:"maxSurge"`
	MaxUnavailable int `json:"maxUnavailable"`
}

// K8sSecret defines model for k8s.Secret.
type K8sSecret struct {
	APIVersion *string               `json:"apiVersion,omitempty"`
	BinaryData *K8sSecret_BinaryData `json:"binaryData,omitempty"`
	Data       *K8sSecret_Data       `json:"data,omitempty"`
	Kind       *string               `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
	Type     *string                                   `json:"type,omitempty"`
}

// K8sSecret_BinaryData defines model for K8sSecret.BinaryData.
type K8sSecret_BinaryData struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sSecret_Data defines model for K8sSecret.Data.
type K8sSecret_Data struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sSecretList defines model for k8s.SecretList.
type K8sSecretList struct {
	APIVersion *string     `json:"apiVersion,omitempty"`
	Items      []K8sSecret `json:"items"`
	Kind       *string     `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sSelfSubjectAccessReview defines model for k8s.SelfSubjectAccessReview.
type K8sSelfSubjectAccessReview struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
	Spec     *K8sSelfSubjectAccessReviewSpec         `json:"spec,omitempty"`
	Status   *K8sSubjectAccessReviewStatus           `json:"status,omitempty"`
}

// K8sSelfSubjectAccessReviewSpec defines model for k8s.SelfSubjectAccessReviewSpec.
type K8sSelfSubjectAccessReviewSpec struct {
	NonResourceAttributes *map[string]interface{} `json:"nonResourceAttributes,omitempty"`
	ResourceAttributes    *map[string]interface{} `json:"resourceAttributes,omitempty"`
}

// K8sService defines model for k8s.Service.
type K8sService struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
	Spec     K8sServiceSpec                            `json:"spec"`
}

// K8sServiceAccount defines model for k8s.ServiceAccount.
type K8sServiceAccount struct {
	APIVersion                   *string `json:"apiVersion,omitempty"`
	AutomountServiceAccountToken *bool   `json:"automountServiceAccountToken,omitempty"`
	Kind                         *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
}

// K8sServiceAccountList defines model for k8s.ServiceAccountList.
type K8sServiceAccountList struct {
	APIVersion *string             `json:"apiVersion,omitempty"`
	Items      []K8sServiceAccount `json:"items"`
	Kind       *string             `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sServiceList defines model for k8s.ServiceList.
type K8sServiceList struct {
	APIVersion *string      `json:"apiVersion,omitempty"`
	Items      []K8sService `json:"items"`
	Kind       *string      `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sServicePort defines model for k8s.ServicePort.
type K8sServicePort struct {
	// FIXME
	AppProtocol *string `json:"appProtocol,omitempty"`

	// FIXME
	Name *string `json:"name,omitempty"`

	// FIXME
	NodePort *int    `json:"nodePort,omitempty"`
	Port     int     `json:"port"`
	Protocol *string `json:"protocol,omitempty"`

	// IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
	TargetPort IoK8sApimachineryPkgUtilIntstrIntOrString `json:"targetPort"`
}

// K8sServiceSpec defines model for k8s.ServiceSpec.
type K8sServiceSpec struct {
	// ignored for helm compat
	ClusterIP *string `json:"clusterIP,omitempty"`

	// ignored for helm compat
	InternalTrafficPolicy *interface{}             `json:"internalTrafficPolicy,omitempty"`
	Ports                 []K8sServicePort         `json:"ports,omitempty"`
	Selector              *K8sServiceSpec_Selector `json:"selector,omitempty"`

	// FIXME, ClientIP, None
	SessionAffinity *string `json:"sessionAffinity,omitempty"`

	// FIXME. ClusterIP, ExternalName, NodePort, LoadBalancer
	Type *string `json:"type,omitempty"`
}

// K8sServiceSpec_Selector defines model for K8sServiceSpec.Selector.
type K8sServiceSpec_Selector struct {
	AdditionalProperties map[string]string `json:"-"`
}

// K8sStorageClass defines model for k8s.StorageClass.
type K8sStorageClass struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand
	AllowVolumeExpansion *bool   `json:"allowVolumeExpansion,omitempty"`
	APIVersion           *string `json:"apiVersion,omitempty"`
	Kind                 *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`

	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions []string `json:"mountOptions,omitempty"`

	// Parameters holds the parameters for the provisioner that should create volumes of this storage class.
	Parameters *K8sStorageClass_Parameters `json:"parameters,omitempty"`

	// Provisioner indicates the type of the provisioner.
	Provisioner string `json:"provisioner"`

	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy *string `json:"reclaimPolicy,omitempty"`

	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.  When unset, VolumeBindingImmediate is used. This field is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode *string `json:"volumeBindingMode,omitempty"`
}

// Parameters holds the parameters for the provisioner that should create volumes of this storage class.
type K8sStorageClass_Parameters struct {
	AdditionalProperties map[string]string `json:"-"`
}

// StorageClassList is a collection of storage classes.
type K8sStorageClassList struct {
	APIVersion *string           `json:"apiVersion,omitempty"`
	Items      []K8sStorageClass `json:"items"`
	Kind       *string           `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sSubjectAccessReviewStatus defines model for k8s.SubjectAccessReviewStatus.
type K8sSubjectAccessReviewStatus struct {
	Allowed         bool    `json:"allowed"`
	Defined         *bool   `json:"defined,omitempty"`
	EvaluationError *bool   `json:"evaluationError,omitempty"`
	Reason          *string `json:"reason,omitempty"`
}

// K8sUser defines model for k8s.User.
type K8sUser struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata *IoK8sApimachineryPkgApisMetaV1ObjectMeta `json:"metadata,omitempty"`
	Spec     *K8sUserSpec                              `json:"spec,omitempty"`
	Tenant   *KraudTenantInfo                          `json:"tenant,omitempty"`
}

// K8sUserList defines model for k8s.UserList.
type K8sUserList struct {
	APIVersion *string   `json:"apiVersion,omitempty"`
	Items      []K8sUser `json:"items"`
	Kind       *string   `json:"kind,omitempty"`

	// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata *IoK8sApimachineryPkgApisMetaV1ListMeta `json:"metadata,omitempty"`
}

// K8sUserSpec defines model for k8s.UserSpec.
type K8sUserSpec struct {
	DisplayName string  `json:"displayName"`
	Email       string  `json:"email"`
	IdpID       *string `json:"idpId,omitempty"`
	Status      *string `json:"status,omitempty"`
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
type K8sVolume struct {
	// name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `json:"name"`

	// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
	PersistentVolumeClaim *K8sPersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`
}

// volumeDevice describes a mapping of a raw block device within a container.
type K8sVolumeDevice struct {
	// devicePath is the path inside of the container that the device will be mapped to.
	DevicePath string `json:"devicePath"`

	// name must match the name of a persistentVolumeClaim in the pod
	Name string `json:"name"`
}

// VolumeMount describes a mounting of a Volume within a container.
type K8sVolumeMount struct {
	// Path within the container at which the volume should be mounted.  Must not contain ':'.
	MountPath string `json:"mountPath"`

	// mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
	MountPropagation *string `json:"mountPropagation,omitempty"`

	// This must match the Name of a Volume.
	Name string `json:"name"`

	// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty"`

	// Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
	SubPathExpr *string `json:"subPathExpr,omitempty"`
}

// KrCradleState defines model for kr.CradleState.
type KrCradleState struct {
	Pod *struct {
		CradleStage *uint32 `json:"CradleStage,omitempty"`
		Error       *string `json:"Error,omitempty"`
		ExitCode    *int    `json:"ExitCode,omitempty"`
		Ip6         *string `json:"IP6,omitempty"`
		LastLog     *string `json:"LastLog,omitempty"`
	} `json:"Pod,omitempty"`

	// Vpc View
	V *map[string]interface{} `json:"V,omitempty"`
}

// KrVmmContainerReport defines model for kr.VmmContainerReport.
type KrVmmContainerReport struct {
	Error    *string `json:"Error,omitempty"`
	ExitCode *int    `json:"ExitCode,omitempty"`
	Log      *string `json:"Log,omitempty"`
	State    *uint32 `json:"State,omitempty"`
}

// KraudAppOverview defines model for kraud.AppOverview.
type KraudAppOverview struct {
	// version changelog
	Changelog *string `json:"changelog,omitempty"`

	// app configuration variables
	Config    *KraudAppOverview_Config `json:"config,omitempty"`
	CreatedAt time.Time                `json:"created_at"`

	// description of the app
	Description string `json:"description"`

	// extension url if any
	ExtURL *string `json:"ext_url,omitempty"`
	FeedID string  `json:"feed_id"`

	// url to the app icon
	IconURL *string `json:"icon_url,omitempty"`
	ID      string  `json:"id"`

	// label, human readable name of the app
	Label string `json:"label"`

	// name of the app
	Name string `json:"name"`

	// post launch description
	PostLaunch *string `json:"post_launch,omitempty"`

	// incremented version number
	Version int `json:"version"`
}

// app configuration variables
type KraudAppOverview_Config struct {
	AdditionalProperties map[string]KraudAppTemplateConfig `json:"-"`
}

// KraudAppTemplateConfig defines model for kraud.AppTemplateConfig.
type KraudAppTemplateConfig struct {
	Default              string                 `json:"default"`
	Description          string                 `json:"description"`
	Kind                 string                 `json:"kind"`
	Label                string                 `json:"label"`
	Required             bool                   `json:"required"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// KraudAppVersion defines model for kraud.AppVersion.
type KraudAppVersion struct {
	// version changelog
	Changelog string    `json:"changelog"`
	CreatedAt time.Time `json:"created_at"`
	ID        string    `json:"id"`

	// incremented version number
	Version int `json:"version"`
}

// KraudAppVersionList defines model for kraud.AppVersionList.
type KraudAppVersionList []KraudAppVersion

// KraudCreateFeed defines model for kraud.CreateFeed.
type KraudCreateFeed struct {
	IconURL string `json:"icon_url"`
	Name    string `json:"name"`
}

// KraudFeed defines model for kraud.Feed.
type KraudFeed struct {
	Apps      []KraudAppOverview `json:"apps,omitempty"`
	CreatedAt time.Time          `json:"created_at"`
	IconURL   string             `json:"icon_url"`
	ID        string             `json:"id"`
	Name      string             `json:"name"`
}

// KraudFeedList defines model for kraud.FeedList.
type KraudFeedList []KraudFeed

// KraudLaunchAppResponse defines model for kraud.LaunchAppResponse.
type KraudLaunchAppResponse struct {
	LaunchID string `json:"launch_id"`
}

// LaunchSettings is the settings for launching an app.
type KraudLaunchSettings struct {
	Config KraudLaunchSettings_Config `json:"config"`

	// The name of the project to launch the app in.
	ProjectName string `json:"project_name"`
}

// KraudLaunchSettings_Config defines model for KraudLaunchSettings.Config.
type KraudLaunchSettings_Config struct {
	AdditionalProperties map[string]string `json:"-"`
}

// KraudSessionInfo defines model for kraud.SessionInfo.
type KraudSessionInfo struct {
	Tenants []KraudSessionTenantInfo `json:"tenants"`
	User    KraudSessionUserInfo     `json:"user"`
}

// KraudSessionTenantInfo defines model for kraud.SessionTenantInfo.
type KraudSessionTenantInfo struct {
	Org         string `json:"org"`
	TelVerified bool   `json:"tel_verified"`
	TenantID    string `json:"tenant_id"`
	UserID      string `json:"user_id"`
}

// KraudSessionUserInfo defines model for kraud.SessionUserInfo.
type KraudSessionUserInfo struct {
	AvatarURL string `json:"avatar_url"`
	Email     string `json:"email"`
	IdpID     string `json:"idp_id"`
	Name      string `json:"name"`
	UserID    string `json:"user_id"`
}

// regular log lines
type KraudWSLaunchLog struct {
	Log string `json:"log"`
}

// metadata
type KraudWSLaunchMeta struct {
	DeploymentAids []string `json:"deployment_aids,omitempty"`
	Error          *string  `json:"error,omitempty"`
}

// String representation of the container state. Can be one of "created",
// "running", "paused", "restarting", "removing", "exited", or "dead".
type ContainerStateStatus struct {
	value string
}

func (t *ContainerStateStatus) ToValue() string {
	return t.value
}
func (t *ContainerStateStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ContainerStateStatus) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ContainerStateStatus) FromValue(value string) error {
	switch value {

	case ContainerStateStatusCreated.value:
		t.value = value
		return nil

	case ContainerStateStatusDead.value:
		t.value = value
		return nil

	case ContainerStateStatusExited.value:
		t.value = value
		return nil

	case ContainerStateStatusPaused.value:
		t.value = value
		return nil

	case ContainerStateStatusRemoving.value:
		t.value = value
		return nil

	case ContainerStateStatusRestarting.value:
		t.value = value
		return nil

	case ContainerStateStatusRunning.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// EndpointPortConfigProtocol defines model for EndpointPortConfig.Protocol.
type EndpointPortConfigProtocol struct {
	value string
}

func (t *EndpointPortConfigProtocol) ToValue() string {
	return t.value
}
func (t *EndpointPortConfigProtocol) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *EndpointPortConfigProtocol) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *EndpointPortConfigProtocol) FromValue(value string) error {
	switch value {

	case EndpointPortConfigProtocolSctp.value:
		t.value = value
		return nil

	case EndpointPortConfigProtocolTCP.value:
		t.value = value
		return nil

	case EndpointPortConfigProtocolUDP.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The mode in which port is published.
//
// <p><br /></p>
//
//   - "ingress" makes the target port accessible on every node,
//     regardless of whether there is a task for the service running on
//     that node or not.
//   - "host" bypasses the routing mesh and publish the port directly on
//     the swarm node where that service is running.
type EndpointPortConfigPublishMode struct {
	value string
}

func (t *EndpointPortConfigPublishMode) ToValue() string {
	return t.value
}
func (t *EndpointPortConfigPublishMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *EndpointPortConfigPublishMode) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *EndpointPortConfigPublishMode) FromValue(value string) error {
	switch value {

	case EndpointPortConfigPublishModeHost.value:
		t.value = value
		return nil

	case EndpointPortConfigPublishModeIngress.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The mode of resolution to use for internal load balancing between tasks.
type EndpointSpecMode struct {
	value string
}

func (t *EndpointSpecMode) ToValue() string {
	return t.value
}
func (t *EndpointSpecMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *EndpointSpecMode) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *EndpointSpecMode) FromValue(value string) error {
	switch value {

	case EndpointSpecModeDnsrr.value:
		t.value = value
		return nil

	case EndpointSpecModeVip.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Status is one of `none`, `starting`, `healthy` or `unhealthy`
//
// - "none"      Indicates there is no healthcheck
// - "starting"  Starting indicates that the container is not yet ready
// - "healthy"   Healthy indicates that the container is running correctly
// - "unhealthy" Unhealthy indicates that the container has a problem
type HealthStatus struct {
	value string
}

func (t *HealthStatus) ToValue() string {
	return t.value
}
func (t *HealthStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *HealthStatus) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *HealthStatus) FromValue(value string) error {
	switch value {

	case HealthStatusHealthy.value:
		t.value = value
		return nil

	case HealthStatusNone.value:
		t.value = value
		return nil

	case HealthStatusStarting.value:
		t.value = value
		return nil

	case HealthStatusUnhealthy.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// cgroup namespace mode for the container. Possible values are:
//
// - `"private"`: the container runs in its own private cgroup namespace
// - `"host"`: use the host system's cgroup namespace
//
// If not specified, the daemon default is used, which can either be `"private"`
// or `"host"`, depending on daemon version, kernel support and configuration.
type HostConfigCgroupnsMode struct {
	value string
}

func (t *HostConfigCgroupnsMode) ToValue() string {
	return t.value
}
func (t *HostConfigCgroupnsMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *HostConfigCgroupnsMode) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *HostConfigCgroupnsMode) FromValue(value string) error {
	switch value {

	case HostConfigCgroupnsModeHost.value:
		t.value = value
		return nil

	case HostConfigCgroupnsModePrivate.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Isolation technology of the container. (Windows only)
type HostConfigIsolation struct {
	value string
}

func (t *HostConfigIsolation) ToValue() string {
	return t.value
}
func (t *HostConfigIsolation) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *HostConfigIsolation) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *HostConfigIsolation) FromValue(value string) error {
	switch value {

	case HostConfigIsolationDefault.value:
		t.value = value
		return nil

	case HostConfigIsolationHyperv.value:
		t.value = value
		return nil

	case HostConfigIsolationProcess.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// HostConfigLogConfigType defines model for HostConfig.LogConfig.Type.
type HostConfigLogConfigType struct {
	value string
}

func (t *HostConfigLogConfigType) ToValue() string {
	return t.value
}
func (t *HostConfigLogConfigType) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *HostConfigLogConfigType) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *HostConfigLogConfigType) FromValue(value string) error {
	switch value {

	case HostConfigLogConfigTypeAwslogs.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeEtwlogs.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeFluentd.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeGelf.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeJSONFile.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeJournald.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeNone.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeSplunk.value:
		t.value = value
		return nil

	case HostConfigLogConfigTypeSyslog.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Current local status of this node.
type LocalNodeState struct {
	value string
}

func (t *LocalNodeState) ToValue() string {
	return t.value
}
func (t *LocalNodeState) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *LocalNodeState) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *LocalNodeState) FromValue(value string) error {
	switch value {

	case LocalNodeStateActive.value:
		t.value = value
		return nil

	case LocalNodeStateEmpty.value:
		t.value = value
		return nil

	case LocalNodeStateError.value:
		t.value = value
		return nil

	case LocalNodeStateInactive.value:
		t.value = value
		return nil

	case LocalNodeStateLocked.value:
		t.value = value
		return nil

	case LocalNodeStatePending.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
type MountBindOptionsPropagation struct {
	value string
}

func (t *MountBindOptionsPropagation) ToValue() string {
	return t.value
}
func (t *MountBindOptionsPropagation) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *MountBindOptionsPropagation) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *MountBindOptionsPropagation) FromValue(value string) error {
	switch value {

	case MountBindOptionsPropagationPrivate.value:
		t.value = value
		return nil

	case MountBindOptionsPropagationRprivate.value:
		t.value = value
		return nil

	case MountBindOptionsPropagationRshared.value:
		t.value = value
		return nil

	case MountBindOptionsPropagationRslave.value:
		t.value = value
		return nil

	case MountBindOptionsPropagationShared.value:
		t.value = value
		return nil

	case MountBindOptionsPropagationSlave.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The mount type. Available types:
//
// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
// - `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
type MountType struct {
	value string
}

func (t *MountType) ToValue() string {
	return t.value
}
func (t *MountType) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *MountType) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *MountType) FromValue(value string) error {
	switch value {

	case MountTypeBind.value:
		t.value = value
		return nil

	case MountTypeNpipe.value:
		t.value = value
		return nil

	case MountTypeTmpfs.value:
		t.value = value
		return nil

	case MountTypeVolume.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The mount type:
//
// - `bind` a mount of a file or directory from the host into the container.
// - `volume` a docker volume with the given `Name`.
// - `tmpfs` a `tmpfs`.
// - `npipe` a named pipe from the host into the container.
type MountPointType struct {
	value string
}

func (t *MountPointType) ToValue() string {
	return t.value
}
func (t *MountPointType) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *MountPointType) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *MountPointType) FromValue(value string) error {
	switch value {

	case MountPointTypeBind.value:
		t.value = value
		return nil

	case MountPointTypeNpipe.value:
		t.value = value
		return nil

	case MountPointTypeTmpfs.value:
		t.value = value
		return nil

	case MountPointTypeVolume.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Availability of the node.
type NodeSpecAvailability struct {
	value string
}

func (t *NodeSpecAvailability) ToValue() string {
	return t.value
}
func (t *NodeSpecAvailability) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *NodeSpecAvailability) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *NodeSpecAvailability) FromValue(value string) error {
	switch value {

	case NodeSpecAvailabilityActive.value:
		t.value = value
		return nil

	case NodeSpecAvailabilityDrain.value:
		t.value = value
		return nil

	case NodeSpecAvailabilityPause.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Role of the node.
type NodeSpecRole struct {
	value string
}

func (t *NodeSpecRole) ToValue() string {
	return t.value
}
func (t *NodeSpecRole) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *NodeSpecRole) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *NodeSpecRole) FromValue(value string) error {
	switch value {

	case NodeSpecRoleManager.value:
		t.value = value
		return nil

	case NodeSpecRoleWorker.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// NodeState represents the state of a node.
type NodeState struct {
	value string
}

func (t *NodeState) ToValue() string {
	return t.value
}
func (t *NodeState) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *NodeState) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *NodeState) FromValue(value string) error {
	switch value {

	case NodeStateDisconnected.value:
		t.value = value
		return nil

	case NodeStateDown.value:
		t.value = value
		return nil

	case NodeStateReady.value:
		t.value = value
		return nil

	case NodeStateUnknown.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// PortType defines model for Port.Type.
type PortType struct {
	value string
}

func (t *PortType) ToValue() string {
	return t.value
}
func (t *PortType) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *PortType) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *PortType) FromValue(value string) error {
	switch value {

	case PortTypeSctp.value:
		t.value = value
		return nil

	case PortTypeTCP.value:
		t.value = value
		return nil

	case PortTypeUDP.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Reachability represents the reachability of a node.
type Reachability struct {
	value string
}

func (t *Reachability) ToValue() string {
	return t.value
}
func (t *Reachability) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *Reachability) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *Reachability) FromValue(value string) error {
	switch value {

	case ReachabilityReachable.value:
		t.value = value
		return nil

	case ReachabilityUnknown.value:
		t.value = value
		return nil

	case ReachabilityUnreachable.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// - Empty string means not to restart
// - `no` Do not automatically restart
// - `always` Always restart
// - `unless-stopped` Restart always except when the user has manually stopped the container
// - `on-failure` Restart only when the container exit code is non-zero
type RestartPolicyName struct {
	value string
}

func (t *RestartPolicyName) ToValue() string {
	return t.value
}
func (t *RestartPolicyName) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *RestartPolicyName) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *RestartPolicyName) FromValue(value string) error {
	switch value {

	case RestartPolicyNameAlways.value:
		t.value = value
		return nil

	case RestartPolicyNameEmpty.value:
		t.value = value
		return nil

	case RestartPolicyNameNo.value:
		t.value = value
		return nil

	case RestartPolicyNameOnFailure.value:
		t.value = value
		return nil

	case RestartPolicyNameUnlessStopped.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Action to take if an rolled back task fails to run, or stops
// running during the rollback.
type ServiceSpecRollbackConfigFailureAction struct {
	value string
}

func (t *ServiceSpecRollbackConfigFailureAction) ToValue() string {
	return t.value
}
func (t *ServiceSpecRollbackConfigFailureAction) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ServiceSpecRollbackConfigFailureAction) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ServiceSpecRollbackConfigFailureAction) FromValue(value string) error {
	switch value {

	case ServiceSpecRollbackConfigFailureActionContinue.value:
		t.value = value
		return nil

	case ServiceSpecRollbackConfigFailureActionPause.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The order of operations when rolling back a task. Either the old
// task is shut down before the new task is started, or the new task
// is started before the old task is shut down.
type ServiceSpecRollbackConfigOrder struct {
	value string
}

func (t *ServiceSpecRollbackConfigOrder) ToValue() string {
	return t.value
}
func (t *ServiceSpecRollbackConfigOrder) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ServiceSpecRollbackConfigOrder) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ServiceSpecRollbackConfigOrder) FromValue(value string) error {
	switch value {

	case ServiceSpecRollbackConfigOrderStartFirst.value:
		t.value = value
		return nil

	case ServiceSpecRollbackConfigOrderStopFirst.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Action to take if an updated task fails to run, or stops running
// during the update.
type ServiceSpecUpdateConfigFailureAction struct {
	value string
}

func (t *ServiceSpecUpdateConfigFailureAction) ToValue() string {
	return t.value
}
func (t *ServiceSpecUpdateConfigFailureAction) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ServiceSpecUpdateConfigFailureAction) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ServiceSpecUpdateConfigFailureAction) FromValue(value string) error {
	switch value {

	case ServiceSpecUpdateConfigFailureActionContinue.value:
		t.value = value
		return nil

	case ServiceSpecUpdateConfigFailureActionPause.value:
		t.value = value
		return nil

	case ServiceSpecUpdateConfigFailureActionRollback.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The order of operations when rolling out an updated task. Either
// the old task is shut down before the new task is started, or the
// new task is started before the old task is shut down.
type ServiceSpecUpdateConfigOrder struct {
	value string
}

func (t *ServiceSpecUpdateConfigOrder) ToValue() string {
	return t.value
}
func (t *ServiceSpecUpdateConfigOrder) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ServiceSpecUpdateConfigOrder) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ServiceSpecUpdateConfigOrder) FromValue(value string) error {
	switch value {

	case ServiceSpecUpdateConfigOrderStartFirst.value:
		t.value = value
		return nil

	case ServiceSpecUpdateConfigOrderStopFirst.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// ServiceUpdateStatusState defines model for ServiceUpdateStatus.State.
type ServiceUpdateStatusState struct {
	value string
}

func (t *ServiceUpdateStatusState) ToValue() string {
	return t.value
}
func (t *ServiceUpdateStatusState) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *ServiceUpdateStatusState) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *ServiceUpdateStatusState) FromValue(value string) error {
	switch value {

	case ServiceUpdateStatusStateCompleted.value:
		t.value = value
		return nil

	case ServiceUpdateStatusStatePaused.value:
		t.value = value
		return nil

	case ServiceUpdateStatusStateUpdating.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Protocol for communication with the external CA (currently
// only `cfssl` is supported).
type SwarmSpecCAConfigExternalCAsProtocol struct {
	value string
}

func (t *SwarmSpecCAConfigExternalCAsProtocol) ToValue() string {
	return t.value
}
func (t *SwarmSpecCAConfigExternalCAsProtocol) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *SwarmSpecCAConfigExternalCAsProtocol) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *SwarmSpecCAConfigExternalCAsProtocol) FromValue(value string) error {
	switch value {

	case SwarmSpecCAConfigExternalCAsProtocolCfssl.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The driver to use for managing cgroups.
type SystemInfoCgroupDriver struct {
	value string
}

func (t *SystemInfoCgroupDriver) ToValue() string {
	return t.value
}
func (t *SystemInfoCgroupDriver) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *SystemInfoCgroupDriver) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *SystemInfoCgroupDriver) FromValue(value string) error {
	switch value {

	case SystemInfoCgroupDriverCgroupfs.value:
		t.value = value
		return nil

	case SystemInfoCgroupDriverNone.value:
		t.value = value
		return nil

	case SystemInfoCgroupDriverSystemd.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The version of the cgroup.
type SystemInfoCgroupVersion struct {
	value string
}

func (t *SystemInfoCgroupVersion) ToValue() string {
	return t.value
}
func (t *SystemInfoCgroupVersion) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *SystemInfoCgroupVersion) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *SystemInfoCgroupVersion) FromValue(value string) error {
	switch value {

	case SystemInfoCgroupVersionN1.value:
		t.value = value
		return nil

	case SystemInfoCgroupVersionN2.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Represents the isolation technology to use as a default for containers.
// The supported values are platform-specific.
//
// If no isolation value is specified on daemon start, on Windows client,
// the default is `hyperv`, and on Windows server, the default is `process`.
//
// This option is currently not used on other platforms.
type SystemInfoIsolation struct {
	value string
}

func (t *SystemInfoIsolation) ToValue() string {
	return t.value
}
func (t *SystemInfoIsolation) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *SystemInfoIsolation) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *SystemInfoIsolation) FromValue(value string) error {
	switch value {

	case SystemInfoIsolationDefault.value:
		t.value = value
		return nil

	case SystemInfoIsolationHyperv.value:
		t.value = value
		return nil

	case SystemInfoIsolationProcess.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Condition for restart.
type TaskSpecRestartPolicyCondition struct {
	value string
}

func (t *TaskSpecRestartPolicyCondition) ToValue() string {
	return t.value
}
func (t *TaskSpecRestartPolicyCondition) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *TaskSpecRestartPolicyCondition) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *TaskSpecRestartPolicyCondition) FromValue(value string) error {
	switch value {

	case TaskSpecRestartPolicyConditionAny.value:
		t.value = value
		return nil

	case TaskSpecRestartPolicyConditionNone.value:
		t.value = value
		return nil

	case TaskSpecRestartPolicyConditionOnFailure.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// Isolation technology of the containers running the service.
// (Windows only)
type TaskSpecContainerSpecIsolation struct {
	value string
}

func (t *TaskSpecContainerSpecIsolation) ToValue() string {
	return t.value
}
func (t *TaskSpecContainerSpecIsolation) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *TaskSpecContainerSpecIsolation) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *TaskSpecContainerSpecIsolation) FromValue(value string) error {
	switch value {

	case TaskSpecContainerSpecIsolationDefault.value:
		t.value = value
		return nil

	case TaskSpecContainerSpecIsolationHyperv.value:
		t.value = value
		return nil

	case TaskSpecContainerSpecIsolationProcess.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// The level at which the volume exists. Either `global` for cluster-wide,
// or `local` for machine level.
type VolumeScope struct {
	value string
}

func (t *VolumeScope) ToValue() string {
	return t.value
}
func (t *VolumeScope) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.value)
}
func (t *VolumeScope) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	return t.FromValue(value)
}
func (t *VolumeScope) FromValue(value string) error {
	switch value {

	case VolumeScopeGlobal.value:
		t.value = value
		return nil

	case VolumeScopeLocal.value:
		t.value = value
		return nil

	}
	return fmt.Errorf("unknown enum value: %v", value)
}

// ListEndpointsAllNamespacesParams defines parameters for ListEndpointsAllNamespaces.
type ListEndpointsAllNamespacesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListNamespacesParams defines parameters for ListNamespaces.
type ListNamespacesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListConfigMapsParams defines parameters for ListConfigMaps.
type ListConfigMapsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListEndpointsParams defines parameters for ListEndpoints.
type ListEndpointsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListNamespacesEventsParams defines parameters for ListNamespacesEvents.
type ListNamespacesEventsParams struct {
	FieldSelector  *string `json:"fieldSelector,omitempty"`
	LabelSelector  *string `json:"labelSelector,omitempty"`
	Limit          *int    `json:"limit,omitempty"`
	Continue       *string `json:"continue,omitempty"`
	Watch          *bool   `json:"watch,omitempty"`
	TimeoutSeconds *int    `json:"timeoutSeconds,omitempty"`
}

// ListPersistentVolumeClaimsParams defines parameters for ListPersistentVolumeClaims.
type ListPersistentVolumeClaimsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListPodsParams defines parameters for ListPods.
type ListPodsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// CreatePodParams defines parameters for CreatePod.
type CreatePodParams struct {
	FieldManager *string `json:"fieldManager,omitempty"`
}

// GetPodLogParams defines parameters for GetPodLog.
type GetPodLogParams struct {
	Container *string `json:"container,omitempty"`
	Follow    *bool   `json:"follow,omitempty"`
}

// ListSecretsParams defines parameters for ListSecrets.
type ListSecretsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListServicesParams defines parameters for ListServices.
type ListServicesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// DeleteNamespaceParams defines parameters for DeleteNamespace.
type DeleteNamespaceParams struct {
	Recursive *bool `json:"recursive,omitempty"`
	Immediate *bool `json:"immediate,omitempty"`
}

// ListNodesParams defines parameters for ListNodes.
type ListNodesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListPodsAllNamespacesParams defines parameters for ListPodsAllNamespaces.
type ListPodsAllNamespacesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListServiceAccountsParams defines parameters for ListServiceAccounts.
type ListServiceAccountsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListServicesAllNamespacesParams defines parameters for ListServicesAllNamespaces.
type ListServicesAllNamespacesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListCertificateSigningRequestsParams defines parameters for ListCertificateSigningRequests.
type ListCertificateSigningRequestsParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// GenerateCertParams defines parameters for GenerateCert.
type GenerateCertParams struct {
	Algo *string  `json:"algo,omitempty"`
	Bits *int     `json:"bits,omitempty"`
	DNS  []string `json:"dns,omitempty"`
}

// VmmReportContainerStateJSONBody defines parameters for VmmReportContainerState.
type VmmReportContainerStateJSONBody KrVmmContainerReport

// CreateFeedJSONBody defines parameters for CreateFeed.
type CreateFeedJSONBody KraudCreateFeed

// LaunchAppJSONBody defines parameters for LaunchApp.
type LaunchAppJSONBody KraudLaunchSettings

// GetFeedAppTemplateParams defines parameters for GetFeedAppTemplate.
type GetFeedAppTemplateParams struct {
	// Get template interpolated for a specific deployment
	Deployment *string `json:"deployment,omitempty"`

	// Get template interpolated for a specific namespace
	Namespace *string `json:"namespace,omitempty"`
}

// GetFeedAppVersionsParams defines parameters for GetFeedAppVersions.
type GetFeedAppVersionsParams struct {
	Tail *int `json:"tail,omitempty"`
}

// CreateImageJSONBody defines parameters for CreateImage.
type CreateImageJSONBody struct {
	Architecture string                 `json:"Architecture"`
	Config       map[string]interface{} `json:"Config"`
	Layers       []KraudLayerReference  `json:"Layers"`
	OciID        string                 `json:"OciID"`
	Ref          string                 `json:"Ref"`
}

// CreateLayerParams defines parameters for CreateLayer.
type CreateLayerParams struct {
	// layer diff id according to OCI spec
	Oid string `json:"oid"`

	// exact sha256 of uploaded content. this may be different than oid if gziped.
	Sha256 string `json:"sha256"`

	// byte size of uploaded content
	Size uint64 `json:"size"`
}

// AuthorizeSessionParams defines parameters for AuthorizeSession.
type AuthorizeSessionParams struct {
	// ingress route id
	RouteID string `json:"route_id"`

	// URL to redirect to after successful login, allows fully transparent authentication
	ReturnTo *string `json:"return_to,omitempty"`
}

// SendTelCodeJSONBody defines parameters for SendTelCode.
type SendTelCodeJSONBody struct {
	CaptchaToken string `json:"captcha_token"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody K8sUserSpec

// ListIngressClassesParams defines parameters for ListIngressClasses.
type ListIngressClassesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListIngressesParams defines parameters for ListIngresses.
type ListIngressesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// ListStorageClassesParams defines parameters for ListStorageClasses.
type ListStorageClassesParams struct {
	FieldSelector *string `json:"fieldSelector,omitempty"`
	LabelSelector *string `json:"labelSelector,omitempty"`
}

// DockerImageBuildParams defines parameters for DockerImageBuild.
type DockerImageBuildParams struct {
	// Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
	Dockerfile *string `json:"dockerfile,omitempty"`

	// A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
	T *string `json:"t,omitempty"`

	// Extra hosts to add to /etc/hosts
	Extrahosts *string `json:"extrahosts,omitempty"`

	// A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
	Remote *string `json:"remote,omitempty"`

	// Suppress verbose build output.
	Q *bool `json:"q,omitempty"`

	// Do not use the cache when building the image.
	Nocache *bool `json:"nocache,omitempty"`

	// JSON array of images used for build cache resolution.
	Cachefrom *string `json:"cachefrom,omitempty"`

	// Attempt to pull the image even if an older image exists locally.
	Pull *string `json:"pull,omitempty"`

	// Remove intermediate containers after a successful build.
	Rm *bool `json:"rm,omitempty"`

	// Always remove intermediate containers, even upon failure.
	Forcerm *bool `json:"forcerm,omitempty"`

	// Set memory limit for build.
	Memory *int `json:"memory,omitempty"`

	// Total memory (memory + swap). Set as `-1` to disable swap.
	Memswap *int `json:"memswap,omitempty"`

	// CPU shares (relative weight).
	Cpushares *int `json:"cpushares,omitempty"`

	// CPUs in which to allow execution (e.g., `0-3`, `0,1`).
	Cpusetcpus *string `json:"cpusetcpus,omitempty"`

	// The length of a CPU period in microseconds.
	Cpuperiod *int `json:"cpuperiod,omitempty"`

	// Microseconds of CPU time that the container can get in a CPU period.
	Cpuquota *int `json:"cpuquota,omitempty"`

	// JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.
	//
	// For example, the build arg `FOO=bar` would become `{"FOO":"bar"}` in JSON. This would result in the query parameter `buildargs={"FOO":"bar"}`. Note that `{"FOO":"bar"}` should be URI component encoded.
	//
	// [Read more about the buildargs instruction.](/engine/reference/builder/#arg)
	Buildargs *string `json:"buildargs,omitempty"`

	// Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
	Shmsize *int `json:"shmsize,omitempty"`

	// Squash the resulting images layers into a single layer. *(Experimental release only.)*
	Squash *bool `json:"squash,omitempty"`

	// Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
	Labels *string `json:"labels,omitempty"`

	// Sets the networking mode for the run commands during build. Supported
	// standard values are: `bridge`, `host`, `none`, and `container:<name|id>`.
	// Any other value is taken as a custom network's name or ID to which this
	// container should connect to.
	Networkmode *string `json:"networkmode,omitempty"`

	// Platform in the format os[/arch[/variant]]
	Platform *string `json:"platform,omitempty"`

	// Target build stage
	Target *string `json:"target,omitempty"`

	// BuildKit output configuration
	Outputs     *string `json:"outputs,omitempty"`
	ContentType *string `json:"Content-type,omitempty"`

	// This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
	//
	// The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
	//
	// ```
	// {
	//   "docker.example.com": {
	//     "username": "janedoe",
	//     "password": "hunter2"
	//   },
	//   "https://index.docker.io/v1/": {
	//     "username": "mobydock",
	//     "password": "conta1n3rize14"
	//   }
	// }
	// ```
	//
	// Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.
	XRegistryConfig *string `json:"X-Registry-Config,omitempty"`
}

// DockerBuildPruneParams defines parameters for DockerBuildPrune.
type DockerBuildPruneParams struct {
	// Amount of disk space in bytes to keep for cache
	KeepStorage *int `json:"keep-storage,omitempty"`

	// Remove all types of build cache
	All *bool `json:"all,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the list of build cache objects.
	//
	// Available filters:
	//
	// - `until=<duration>`: duration relative to daemon's time, during which build cache was not used, in Go's duration format (e.g., '24h')
	// - `id=<id>`
	// - `parent=<id>`
	// - `type=<string>`
	// - `description=<string>`
	// - `inuse`
	// - `shared`
	// - `private`
	Filters *string `json:"filters,omitempty"`
}

// DockerImageCommitParams defines parameters for DockerImageCommit.
type DockerImageCommitParams struct {
	// The ID or name of the container to commit
	Container *string `json:"container,omitempty"`

	// Repository name for the created image
	Repo *string `json:"repo,omitempty"`

	// Tag name for the create image
	Tag *string `json:"tag,omitempty"`

	// Commit message
	Comment *string `json:"comment,omitempty"`

	// Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
	Author *string `json:"author,omitempty"`

	// Whether to pause the container before committing
	Pause *bool `json:"pause,omitempty"`

	// `Dockerfile` instructions to apply while committing
	Changes *string `json:"changes,omitempty"`
}

// DockerConfigListParams defines parameters for DockerConfigList.
type DockerConfigListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the configs list.
	//
	// Available filters:
	//
	// - `id=<config id>`
	// - `label=<key> or label=<key>=value`
	// - `name=<config name>`
	// - `names=<config name>`
	Filters *string `json:"filters,omitempty"`
}

// DockerConfigCreateJSONBody defines parameters for DockerConfigCreate.
type DockerConfigCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ConfigSpec)
	ConfigSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// DockerConfigUpdateJSONBody defines parameters for DockerConfigUpdate.
type DockerConfigUpdateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ConfigSpec)
	ConfigSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// DockerConfigUpdateParams defines parameters for DockerConfigUpdate.
type DockerConfigUpdateParams struct {
	// The version number of the config object being updated. This is
	// required to avoid conflicting writes.
	Version int `json:"version"`
}

// DockerContainerCreateJSONBody defines parameters for DockerContainerCreate.
type DockerContainerCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ContainerConfig)
	ContainerConfig `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Container configuration that depends on the host we are running on
	HostConfig *HostConfig `json:"HostConfig,omitempty"`

	// NetworkingConfig represents the container's networking configuration for
	// each of its interfaces.
	// It is used for the networking configs specified in the `docker create`
	// and `docker network connect` commands.
	NetworkingConfig *NetworkingConfig `json:"NetworkingConfig,omitempty"`
}

// DockerContainerCreateParams defines parameters for DockerContainerCreate.
type DockerContainerCreateParams struct {
	// Assign the specified name to the container. Must match
	// `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.
	Name *string `json:"name,omitempty"`
}

// DockerContainerListParams defines parameters for DockerContainerList.
type DockerContainerListParams struct {
	// Return all containers. By default, only running containers are shown.
	All *bool `json:"all,omitempty"`

	// Return this number of most recently created containers, including
	// non-running ones.
	Limit *int `json:"limit,omitempty"`

	// Return the size of container as fields `SizeRw` and `SizeRootFs`.
	Size *bool `json:"size,omitempty"`

	// Filters to process on the container list, encoded as JSON (a
	// `map[string][]string`). For example, `{"status": ["paused"]}` will
	// only return paused containers.
	//
	// Available filters:
	//
	// - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`)
	// - `before`=(`<container id>` or `<container name>`)
	// - `expose`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`)
	// - `exited=<int>` containers with exit code of `<int>`
	// - `health`=(`starting`|`healthy`|`unhealthy`|`none`)
	// - `id=<ID>` a container's ID
	// - `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only)
	// - `is-task=`(`true`|`false`)
	// - `label=key` or `label="key=value"` of a container label
	// - `name=<name>` a container's name
	// - `network`=(`<network id>` or `<network name>`)
	// - `publish`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`)
	// - `since`=(`<container id>` or `<container name>`)
	// - `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`)
	// - `volume`=(`<volume name>` or `<mount point destination>`)
	Filters *string `json:"filters,omitempty"`
}

// DockerContainerPruneParams defines parameters for DockerContainerPrune.
type DockerContainerPruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// DockerContainerDeleteParams defines parameters for DockerContainerDelete.
type DockerContainerDeleteParams struct {
	// Remove anonymous volumes associated with the container.
	V *bool `json:"v,omitempty"`

	// If the container is running, kill it before removing it.
	Force *bool `json:"force,omitempty"`

	// Remove the specified link associated with the container.
	Link *bool `json:"link,omitempty"`
}

// DockerContainerArchiveParams defines parameters for DockerContainerArchive.
type DockerContainerArchiveParams struct {
	// Resource in the container’s filesystem to archive.
	Path string `json:"path"`
}

// DockerContainerArchiveInfoParams defines parameters for DockerContainerArchiveInfo.
type DockerContainerArchiveInfoParams struct {
	// Resource in the container’s filesystem to archive.
	Path string `json:"path"`
}

// DockerPutContainerArchiveParams defines parameters for DockerPutContainerArchive.
type DockerPutContainerArchiveParams struct {
	// Path to a directory in the container to extract the archive’s contents into.
	Path string `json:"path"`

	// If `1`, `true`, or `True` then it will be an error if unpacking the
	// given content would cause an existing directory to be replaced with
	// a non-directory and vice versa.
	NoOverwriteDirNonDir *string `json:"noOverwriteDirNonDir,omitempty"`

	// If `1`, `true`, then it will copy UID/GID maps to the dest file or
	// dir
	CopyUIDGID *string `json:"copyUIDGID,omitempty"`
}

// DockerContainerAttachParams defines parameters for DockerContainerAttach.
type DockerContainerAttachParams struct {
	// Override the key sequence for detaching a container.Format is a single
	// character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`,
	// `@`, `^`, `[`, `,` or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`

	// Replay previous logs from the container.
	//
	// This is useful for attaching to a container that has started and you
	// want to output everything since the container started.
	//
	// If `stream` is also enabled, once all the previous output has been
	// returned, it will seamlessly transition into streaming current
	// output.
	Logs *bool `json:"logs,omitempty"`

	// Stream attached streams from the time the request was made onwards.
	Stream *bool `json:"stream,omitempty"`

	// Attach to `stdin`
	Stdin *bool `json:"stdin,omitempty"`

	// Attach to `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Attach to `stderr`
	Stderr *bool `json:"stderr,omitempty"`
}

// DockerContainerAttachWebsocketParams defines parameters for DockerContainerAttachWebsocket.
type DockerContainerAttachWebsocketParams struct {
	// Override the key sequence for detaching a container.Format is a single
	// character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`,
	// `@`, `^`, `[`, `,`, or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`

	// Return logs
	Logs *bool `json:"logs,omitempty"`

	// Return stream
	Stream *bool `json:"stream,omitempty"`
}

// DockerContainerInspectParams defines parameters for DockerContainerInspect.
type DockerContainerInspectParams struct {
	// Return the size of container as fields `SizeRw` and `SizeRootFs`
	Size *bool `json:"size,omitempty"`
}

// DockerContainerKillParams defines parameters for DockerContainerKill.
type DockerContainerKillParams struct {
	// Signal to send to the container as an integer or string (e.g. `SIGINT`)
	Signal *string `json:"signal,omitempty"`
}

// DockerContainerLogsParams defines parameters for DockerContainerLogs.
type DockerContainerLogsParams struct {
	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Only return logs before this time, as a UNIX timestamp
	Until *int `json:"until,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// DockerContainerRenameParams defines parameters for DockerContainerRename.
type DockerContainerRenameParams struct {
	// New name for the container
	Name string `json:"name"`
}

// DockerContainerResizeParams defines parameters for DockerContainerResize.
type DockerContainerResizeParams struct {
	// Height of the TTY session in characters
	H *int `json:"h,omitempty"`

	// Width of the TTY session in characters
	W *int `json:"w,omitempty"`
}

// DockerContainerRestartParams defines parameters for DockerContainerRestart.
type DockerContainerRestartParams struct {
	// Number of seconds to wait before killing the container
	T *int `json:"t,omitempty"`
}

// DockerContainerStartParams defines parameters for DockerContainerStart.
type DockerContainerStartParams struct {
	// Override the key sequence for detaching a container. Format is a
	// single character `[a-Z]` or `ctrl-<value>` where `<value>` is one
	// of: `a-z`, `@`, `^`, `[`, `,` or `_`.
	DetachKeys *string `json:"detachKeys,omitempty"`
}

// DockerContainerStatsParams defines parameters for DockerContainerStats.
type DockerContainerStatsParams struct {
	// Stream the output. If false, the stats will be output once and then
	// it will disconnect.
	Stream *bool `json:"stream,omitempty"`

	// Only get a single stat instead of waiting for 2 cycles. Must be used
	// with `stream=false`.
	OneShot *bool `json:"one-shot,omitempty"`
}

// DockerContainerStopParams defines parameters for DockerContainerStop.
type DockerContainerStopParams struct {
	// Number of seconds to wait before killing the container
	T *int `json:"t,omitempty"`
}

// DockerContainerTopParams defines parameters for DockerContainerTop.
type DockerContainerTopParams struct {
	// The arguments to pass to `ps`. For example, `aux`
	PsArgs *string `json:"ps_args,omitempty"`
}

// DockerContainerWaitParams defines parameters for DockerContainerWait.
type DockerContainerWaitParams struct {
	// Wait until a container state reaches the given condition.
	//
	// Defaults to `not-running` if omitted or empty.
	Condition *string `json:"condition,omitempty"`
}

// DockerSystemEventsParams defines parameters for DockerSystemEvents.
type DockerSystemEventsParams struct {
	// Show events created since this timestamp then stream new events.
	Since *string `json:"since,omitempty"`

	// Show events created until this timestamp then stop streaming.
	Until *string `json:"until,omitempty"`

	// A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:
	//
	// - `config=<string>` config name or ID
	// - `container=<string>` container name or ID
	// - `daemon=<string>` daemon name or ID
	// - `event=<string>` event type
	// - `image=<string>` image name or ID
	// - `label=<string>` image or container label
	// - `network=<string>` network name or ID
	// - `node=<string>` node ID
	// - `plugin`=<string> plugin name or ID
	// - `scope`=<string> local or swarm
	// - `secret=<string>` secret name or ID
	// - `service=<string>` service name or ID
	// - `type=<string>` object to filter by, one of `container`, `image`, `volume`, `network`, `daemon`, `plugin`, `node`, `service`, `secret` or `config`
	// - `volume=<string>` volume name
	Filters *string `json:"filters,omitempty"`
}

// DockerExecResizeParams defines parameters for DockerExecResize.
type DockerExecResizeParams struct {
	// Height of the TTY session in characters
	H *int `json:"h,omitempty"`

	// Width of the TTY session in characters
	W *int `json:"w,omitempty"`
}

// DockerImageCreateParams defines parameters for DockerImageCreate.
type DockerImageCreateParams struct {
	// Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
	FromImage *string `json:"fromImage,omitempty"`

	// Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.
	FromSrc *string `json:"fromSrc,omitempty"`

	// Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
	Repo *string `json:"repo,omitempty"`

	// Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
	Tag *string `json:"tag,omitempty"`

	// Set commit message for imported image.
	Message *string `json:"message,omitempty"`

	// Apply `Dockerfile` instructions to the image that is created,
	// for example: `changes=ENV DEBUG=true`.
	// Note that `ENV DEBUG=true` should be URI component encoded.
	//
	// Supported `Dockerfile` instructions:
	// `CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`
	Changes []interface{} `json:"changes,omitempty"`

	// Platform in the format os[/arch[/variant]]
	Platform *string `json:"platform,omitempty"`

	// A base64url-encoded auth configuration.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// DockerImageGetAllParams defines parameters for DockerImageGetAll.
type DockerImageGetAllParams struct {
	// Image names to filter by
	Names []string `json:"names,omitempty"`
}

// DockerImageListParams defines parameters for DockerImageList.
type DockerImageListParams struct {
	// Show all images. Only images from a final layer (no children) are shown by default.
	All *bool `json:"all,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the images list.
	//
	// Available filters:
	//
	// - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
	// - `dangling=true`
	// - `label=key` or `label="key=value"` of an image label
	// - `reference`=(`<image-name>[:<tag>]`)
	// - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
	Filters *string `json:"filters,omitempty"`

	// Show digest information as a `RepoDigests` field on each image.
	Digests *bool `json:"digests,omitempty"`
}

// DockerImageLoadParams defines parameters for DockerImageLoad.
type DockerImageLoadParams struct {
	// Suppress progress details during load.
	Quiet *bool `json:"quiet,omitempty"`
}

// DockerImagePruneParams defines parameters for DockerImagePrune.
type DockerImagePruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), prune only
	//    unused *and* untagged images. When set to `false`
	//    (or `0`), all unused images are pruned.
	// - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// DockerImageSearchParams defines parameters for DockerImageSearch.
type DockerImageSearchParams struct {
	// Term to search
	Term string `json:"term"`

	// Maximum number of results to return
	Limit *int `json:"limit,omitempty"`

	// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
	//
	// - `is-automated=(true|false)`
	// - `is-official=(true|false)`
	// - `stars=<number>` Matches images that has at least 'number' stars.
	Filters *string `json:"filters,omitempty"`
}

// DockerImageDeleteParams defines parameters for DockerImageDelete.
type DockerImageDeleteParams struct {
	// Remove the image even if it is being used by stopped containers or has other tags
	Force *bool `json:"force,omitempty"`

	// Do not delete untagged parent images
	Noprune *bool `json:"noprune,omitempty"`
}

// DockerImagePushParams defines parameters for DockerImagePush.
type DockerImagePushParams struct {
	// The tag to associate with the image on the registry.
	Tag *string `json:"tag,omitempty"`

	// A base64url-encoded auth configuration.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth string `json:"X-Registry-Auth"`
}

// DockerImageTagParams defines parameters for DockerImageTag.
type DockerImageTagParams struct {
	// The repository to tag in. For example, `someuser/someimage`.
	Repo *string `json:"repo,omitempty"`

	// The name of the new tag.
	Tag *string `json:"tag,omitempty"`
}

// DockerNetworkListParams defines parameters for DockerNetworkList.
type DockerNetworkListParams struct {
	// JSON encoded value of the filters (a `map[string][]string`) to process
	// on the networks list.
	//
	// Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), returns all
	//    networks that are not in use by a container. When set to `false`
	//    (or `0`), only networks that are in use by one or more
	//    containers are returned.
	// - `driver=<driver-name>` Matches a network's driver.
	// - `id=<network-id>` Matches all or part of a network ID.
	// - `label=<key>` or `label=<key>=<value>` of a network label.
	// - `name=<network-name>` Matches all or part of a network name.
	// - `scope=["swarm"|"global"|"local"]` Filters networks by scope (`swarm`, `global`, or `local`).
	// - `type=["custom"|"builtin"]` Filters networks by type. The `custom` keyword returns all user-defined networks.
	Filters *string `json:"filters,omitempty"`
}

// DockerNetworkPruneParams defines parameters for DockerNetworkPrune.
type DockerNetworkPruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `until=<timestamp>` Prune networks created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// DockerNetworkInspectParams defines parameters for DockerNetworkInspect.
type DockerNetworkInspectParams struct {
	// Detailed inspect output for troubleshooting
	Verbose *bool `json:"verbose,omitempty"`

	// Filter the network by scope (swarm, global, or local)
	Scope *string `json:"scope,omitempty"`
}

// DockerNodeListParams defines parameters for DockerNodeList.
type DockerNodeListParams struct {
	// Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `id=<node id>`
	// - `label=<engine label>`
	// - `membership=`(`accepted`|`pending`)`
	// - `name=<node name>`
	// - `node.label=<node label>`
	// - `role=`(`manager`|`worker`)`
	Filters *string `json:"filters,omitempty"`
}

// DockerNodeDeleteParams defines parameters for DockerNodeDelete.
type DockerNodeDeleteParams struct {
	// Force remove a node from the swarm
	Force *bool `json:"force,omitempty"`
}

// DockerNodeUpdateParams defines parameters for DockerNodeUpdate.
type DockerNodeUpdateParams struct {
	// The version number of the node object being updated. This is required
	// to avoid conflicting writes.
	Version int `json:"version"`
}

// DockerPluginListParams defines parameters for DockerPluginList.
type DockerPluginListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the plugin list.
	//
	// Available filters:
	//
	// - `capability=<capability name>`
	// - `enable=<true>|<false>`
	Filters *string `json:"filters,omitempty"`
}

// DockerPluginCreateParams defines parameters for DockerPluginCreate.
type DockerPluginCreateParams struct {
	// The name of the plugin. The `:latest` tag is optional, and is the
	// default if omitted.
	Name string `json:"name"`
}

// DockerGetPluginPrivilegesParams defines parameters for DockerGetPluginPrivileges.
type DockerGetPluginPrivilegesParams struct {
	// The name of the plugin. The `:latest` tag is optional, and is the
	// default if omitted.
	Remote string `json:"remote"`
}

// DockerPluginPullParams defines parameters for DockerPluginPull.
type DockerPluginPullParams struct {
	// Remote reference for plugin to install.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Remote string `json:"remote"`

	// Local name for the pulled plugin.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Name *string `json:"name,omitempty"`

	// A base64url-encoded auth configuration to use when pulling a plugin
	// from a registry.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// DockerPluginDeleteParams defines parameters for DockerPluginDelete.
type DockerPluginDeleteParams struct {
	// Disable the plugin before removing. This may result in issues if the
	// plugin is in use by a container.
	Force *bool `json:"force,omitempty"`
}

// DockerPluginEnableParams defines parameters for DockerPluginEnable.
type DockerPluginEnableParams struct {
	// Set the HTTP client timeout (in seconds)
	Timeout *int `json:"timeout,omitempty"`
}

// DockerPluginUpgradeParams defines parameters for DockerPluginUpgrade.
type DockerPluginUpgradeParams struct {
	// Remote reference to upgrade to.
	//
	// The `:latest` tag is optional, and is used as the default if omitted.
	Remote string `json:"remote"`

	// A base64url-encoded auth configuration to use when pulling a plugin
	// from a registry.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// DockerSecretListParams defines parameters for DockerSecretList.
type DockerSecretListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the secrets list.
	//
	// Available filters:
	//
	// - `id=<secret id>`
	// - `label=<key> or label=<key>=value`
	// - `name=<secret name>`
	// - `names=<secret name>`
	Filters *string `json:"filters,omitempty"`
}

// DockerSecretCreateJSONBody defines parameters for DockerSecretCreate.
type DockerSecretCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/SecretSpec)
	SecretSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// DockerSecretUpdateParams defines parameters for DockerSecretUpdate.
type DockerSecretUpdateParams struct {
	// The version number of the secret object being updated. This is
	// required to avoid conflicting writes.
	Version int `json:"version"`
}

// DockerServiceListParams defines parameters for DockerServiceList.
type DockerServiceListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the services list.
	//
	// Available filters:
	//
	// - `id=<service id>`
	// - `label=<service label>`
	// - `mode=["replicated"|"global"]`
	// - `name=<service name>`
	Filters *string `json:"filters,omitempty"`

	// Include service status, with count of running and desired tasks.
	Status *bool `json:"status,omitempty"`
}

// DockerServiceCreateJSONBody defines parameters for DockerServiceCreate.
type DockerServiceCreateJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/ServiceSpec)
	ServiceSpec `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// DockerServiceCreateParams defines parameters for DockerServiceCreate.
type DockerServiceCreateParams struct {
	// A base64url-encoded auth configuration for pulling from private
	// registries.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// DockerServiceInspectParams defines parameters for DockerServiceInspect.
type DockerServiceInspectParams struct {
	// Fill empty fields with default values.
	InsertDefaults *bool `json:"insertDefaults,omitempty"`
}

// DockerServiceArchiveParams defines parameters for DockerServiceArchive.
type DockerServiceArchiveParams struct {
	// Resource in the container’s filesystem to archive.
	Path string `json:"path"`
}

// DockerServiceArchiveInfoParams defines parameters for DockerServiceArchiveInfo.
type DockerServiceArchiveInfoParams struct {
	// Resource in the container’s filesystem to archive.
	Path string `json:"path"`
}

// DockerServiceLogsParams defines parameters for DockerServiceLogs.
type DockerServiceLogsParams struct {
	// Show service context and extra details provided to logs.
	Details *bool `json:"details,omitempty"`

	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Upgrade to websocket
	Websocket *bool `json:"websocket,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// DockerServiceUpdateParams defines parameters for DockerServiceUpdate.
type DockerServiceUpdateParams struct {
	// The version number of the service object being updated. This is
	// required to avoid conflicting writes.
	// This version number should be the value as currently set on the
	// service *before* the update. You can find the current version by
	// calling `GET /services/{id}`
	Version int `json:"version"`

	// If the `X-Registry-Auth` header is not specified, this parameter
	// indicates where to find registry authorization credentials.
	RegistryAuthFrom *string `json:"registryAuthFrom,omitempty"`

	// Set to this parameter to `previous` to cause a server-side rollback
	// to the previous service spec. The supplied spec will be ignored in
	// this case.
	Rollback *string `json:"rollback,omitempty"`

	// A base64url-encoded auth configuration for pulling from private
	// registries.
	//
	// Refer to the [authentication section](#section/Authentication) for
	// details.
	XRegistryAuth *string `json:"X-Registry-Auth,omitempty"`
}

// DockerSwarmLeaveParams defines parameters for DockerSwarmLeave.
type DockerSwarmLeaveParams struct {
	// Force leave swarm, even if this is the last manager or that it will
	// break the cluster.
	Force *bool `json:"force,omitempty"`
}

// DockerSwarmUpdateParams defines parameters for DockerSwarmUpdate.
type DockerSwarmUpdateParams struct {
	// The version number of the swarm object being updated. This is
	// required to avoid conflicting writes.
	Version int `json:"version"`

	// Rotate the worker join token.
	RotateWorkerToken *bool `json:"rotateWorkerToken,omitempty"`

	// Rotate the manager join token.
	RotateManagerToken *bool `json:"rotateManagerToken,omitempty"`

	// Rotate the manager unlock key.
	RotateManagerUnlockKey *bool `json:"rotateManagerUnlockKey,omitempty"`
}

// DockerTaskListParams defines parameters for DockerTaskList.
type DockerTaskListParams struct {
	// A JSON encoded value of the filters (a `map[string][]string`) to
	// process on the tasks list.
	//
	// Available filters:
	//
	// - `desired-state=(running | shutdown | accepted)`
	// - `id=<task id>`
	// - `label=key` or `label="key=value"`
	// - `name=<task name>`
	// - `node=<node id or name>`
	// - `service=<service name>`
	Filters *string `json:"filters,omitempty"`
}

// DockerTaskLogsParams defines parameters for DockerTaskLogs.
type DockerTaskLogsParams struct {
	// Show task context and extra details provided to logs.
	Details *bool `json:"details,omitempty"`

	// Keep connection after returning logs.
	Follow *bool `json:"follow,omitempty"`

	// Return logs from `stdout`
	Stdout *bool `json:"stdout,omitempty"`

	// Return logs from `stderr`
	Stderr *bool `json:"stderr,omitempty"`

	// Only return logs since this time, as a UNIX timestamp
	Since *int `json:"since,omitempty"`

	// Add timestamps to every log line
	Timestamps *bool `json:"timestamps,omitempty"`

	// Only return this number of log lines from the end of the logs.
	// Specify as an integer or `all` to output all log lines.
	Tail *string `json:"tail,omitempty"`
}

// DockerVolumeListParams defines parameters for DockerVolumeList.
type DockerVolumeListParams struct {
	// JSON encoded value of the filters (a `map[string][]string`) to
	// process on the volumes list. Available filters:
	//
	// - `dangling=<boolean>` When set to `true` (or `1`), returns all
	//    volumes that are not in use by a container. When set to `false`
	//    (or `0`), only volumes that are in use by one or more
	//    containers are returned.
	// - `driver=<volume-driver-name>` Matches volumes based on their driver.
	// - `label=<key>` or `label=<key>:<value>` Matches volumes based on
	//    the presence of a `label` alone or a `label` and a value.
	// - `name=<volume-name>` Matches all or part of a volume name.
	Filters *string `json:"filters,omitempty"`
}

// DockerVolumeCreateJSONBody defines parameters for DockerVolumeCreate.
type DockerVolumeCreateJSONBody VolumeCreateOptions

// DockerVolumePruneParams defines parameters for DockerVolumePrune.
type DockerVolumePruneParams struct {
	// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
	//
	// Available filters:
	// - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
	Filters *string `json:"filters,omitempty"`
}

// DockerVolumeDeleteParams defines parameters for DockerVolumeDelete.
type DockerVolumeDeleteParams struct {
	// Force the removal of the volume
	Force *bool `json:"force,omitempty"`
}

// VmmReportContainerStateJSONRequestBody defines body for VmmReportContainerState for application/json ContentType.
type VmmReportContainerStateJSONRequestBody VmmReportContainerStateJSONBody

// Bind implements render.Binder.
func (VmmReportContainerStateJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// CreateFeedJSONRequestBody defines body for CreateFeed for application/json ContentType.
type CreateFeedJSONRequestBody CreateFeedJSONBody

// Bind implements render.Binder.
func (CreateFeedJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// LaunchAppJSONRequestBody defines body for LaunchApp for application/json ContentType.
type LaunchAppJSONRequestBody LaunchAppJSONBody

// Bind implements render.Binder.
func (LaunchAppJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody CreateImageJSONBody

// Bind implements render.Binder.
func (CreateImageJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// SendTelCodeJSONRequestBody defines body for SendTelCode for application/json ContentType.
type SendTelCodeJSONRequestBody SendTelCodeJSONBody

// Bind implements render.Binder.
func (SendTelCodeJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// Bind implements render.Binder.
func (CreateUserJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// DockerConfigCreateJSONRequestBody defines body for DockerConfigCreate for application/json ContentType.
type DockerConfigCreateJSONRequestBody DockerConfigCreateJSONBody

// DockerConfigUpdateJSONRequestBody defines body for DockerConfigUpdate for application/json ContentType.
type DockerConfigUpdateJSONRequestBody DockerConfigUpdateJSONBody

// DockerContainerCreateJSONRequestBody defines body for DockerContainerCreate for application/json ContentType.
type DockerContainerCreateJSONRequestBody DockerContainerCreateJSONBody

// DockerSecretCreateJSONRequestBody defines body for DockerSecretCreate for application/json ContentType.
type DockerSecretCreateJSONRequestBody DockerSecretCreateJSONBody

// DockerServiceCreateJSONRequestBody defines body for DockerServiceCreate for application/json ContentType.
type DockerServiceCreateJSONRequestBody DockerServiceCreateJSONBody

// DockerVolumeCreateJSONRequestBody defines body for DockerVolumeCreate for application/json ContentType.
type DockerVolumeCreateJSONRequestBody DockerVolumeCreateJSONBody

// Bind implements render.Binder.
func (DockerVolumeCreateJSONRequestBody) Bind(*http.Request) error {
	return nil
}

// Response is a common response struct for all the API calls.
// A Response object may be instantiated via functions for specific operation responses.
// It may also be instantiated directly, for the purpose of responding with a single status code.
type Response struct {
	body        interface{}
	Code        int
	contentType string
}

// Render implements the render.Renderer interface. It sets the Content-Type header
// and status code based on the response definition.
func (resp *Response) Render(w http.ResponseWriter, r *http.Request) error {
	w.Header().Set("Content-Type", resp.contentType)
	render.Status(r, resp.Code)
	return nil
}

// Status is a builder method to override the default status code for a response.
func (resp *Response) Status(code int) *Response {
	resp.Code = code
	return resp
}

// ContentType is a builder method to override the default content type for a response.
func (resp *Response) ContentType(contentType string) *Response {
	resp.contentType = contentType
	return resp
}

// MarshalJSON implements the json.Marshaler interface.
// This is used to only marshal the body of the response.
func (resp *Response) MarshalJSON() ([]byte, error) {
	return json.Marshal(resp.body)
}

// MarshalXML implements the xml.Marshaler interface.
// This is used to only marshal the body of the response.
func (resp *Response) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.Encode(resp.body)
}

// GetIndexJSON200Response is a constructor method for a GetIndex response.
// A *Response is returned with the configured status code and content type from the spec.
func GetIndexJSON200Response(body Index) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetCoreAPIVersionsJSON200Response is a constructor method for a GetCoreAPIVersions response.
// A *Response is returned with the configured status code and content type from the spec.
func GetCoreAPIVersionsJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIVersions) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetCoreV1apiResourcesJSON200Response is a constructor method for a GetCoreV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetCoreV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListEndpointsAllNamespacesJSON200Response is a constructor method for a ListEndpointsAllNamespaces response.
// A *Response is returned with the configured status code and content type from the spec.
func ListEndpointsAllNamespacesJSON200Response(body K8sEndpointsList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListNamespacesJSON200Response is a constructor method for a ListNamespaces response.
// A *Response is returned with the configured status code and content type from the spec.
func ListNamespacesJSON200Response(body K8sNamespaceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetDefaultHTTPBackendJSON200Response is a constructor method for a GetDefaultHTTPBackend response.
// A *Response is returned with the configured status code and content type from the spec.
func GetDefaultHTTPBackendJSON200Response(body K8sIngressRuleHTTPPathBackend) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetDefaultHTTPBackendServiceJSON200Response is a constructor method for a GetDefaultHTTPBackendService response.
// A *Response is returned with the configured status code and content type from the spec.
func GetDefaultHTTPBackendServiceJSON200Response(body K8sService) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListConfigMapsJSON200Response is a constructor method for a ListConfigMaps response.
// A *Response is returned with the configured status code and content type from the spec.
func ListConfigMapsJSON200Response(body K8sConfigMapList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetConfigMapJSON200Response is a constructor method for a GetConfigMap response.
// A *Response is returned with the configured status code and content type from the spec.
func GetConfigMapJSON200Response(body K8sConfigMap) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchConfigMapJSON200Response is a constructor method for a PatchConfigMap response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchConfigMapJSON200Response(body K8sConfigMap) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListEndpointsJSON200Response is a constructor method for a ListEndpoints response.
// A *Response is returned with the configured status code and content type from the spec.
func ListEndpointsJSON200Response(body K8sEndpointsList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetEndpointsJSON200Response is a constructor method for a GetEndpoints response.
// A *Response is returned with the configured status code and content type from the spec.
func GetEndpointsJSON200Response(body K8sEndpoints) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListNamespacesEventsJSON200Response is a constructor method for a ListNamespacesEvents response.
// A *Response is returned with the configured status code and content type from the spec.
func ListNamespacesEventsJSON200Response(body K8sEventList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListPersistentVolumeClaimsJSON200Response is a constructor method for a ListPersistentVolumeClaims response.
// A *Response is returned with the configured status code and content type from the spec.
func ListPersistentVolumeClaimsJSON200Response(body K8sPersistentVolumeClaimList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetPersistentVolumeClaimJSON200Response is a constructor method for a GetPersistentVolumeClaim response.
// A *Response is returned with the configured status code and content type from the spec.
func GetPersistentVolumeClaimJSON200Response(body K8sPersistentVolumeClaim) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchPersistentVolumeClaimJSON200Response is a constructor method for a PatchPersistentVolumeClaim response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchPersistentVolumeClaimJSON200Response(body K8sPersistentVolumeClaim) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListPodsJSON200Response is a constructor method for a ListPods response.
// A *Response is returned with the configured status code and content type from the spec.
func ListPodsJSON200Response(body K8sPodList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetPodJSON200Response is a constructor method for a GetPod response.
// A *Response is returned with the configured status code and content type from the spec.
func GetPodJSON200Response(body K8sPod) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchPodJSON200Response is a constructor method for a PatchPod response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchPodJSON200Response(body K8sPod) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetPodLogJSON200Response is a constructor method for a GetPodLog response.
// A *Response is returned with the configured status code and content type from the spec.
func GetPodLogJSON200Response(body K8sPod) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListSecretsJSON200Response is a constructor method for a ListSecrets response.
// A *Response is returned with the configured status code and content type from the spec.
func ListSecretsJSON200Response(body K8sSecretList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetSecretJSON200Response is a constructor method for a GetSecret response.
// A *Response is returned with the configured status code and content type from the spec.
func GetSecretJSON200Response(body K8sSecret) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchSecretJSON200Response is a constructor method for a PatchSecret response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchSecretJSON200Response(body K8sSecret) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ReplaceSecretJSON200Response is a constructor method for a ReplaceSecret response.
// A *Response is returned with the configured status code and content type from the spec.
func ReplaceSecretJSON200Response(body K8sSecret) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListServicesJSON200Response is a constructor method for a ListServices response.
// A *Response is returned with the configured status code and content type from the spec.
func ListServicesJSON200Response(body K8sServiceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetServiceJSON200Response is a constructor method for a GetService response.
// A *Response is returned with the configured status code and content type from the spec.
func GetServiceJSON200Response(body K8sService) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchServiceJSON200Response is a constructor method for a PatchService response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchServiceJSON200Response(body K8sService) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetNamespaceJSON200Response is a constructor method for a GetNamespace response.
// A *Response is returned with the configured status code and content type from the spec.
func GetNamespaceJSON200Response(body K8sNamespace) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchNamespaceJSON200Response is a constructor method for a PatchNamespace response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchNamespaceJSON200Response(body K8sNamespace) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListNodesJSON200Response is a constructor method for a ListNodes response.
// A *Response is returned with the configured status code and content type from the spec.
func ListNodesJSON200Response(body K8sNodeList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetNodeJSON200Response is a constructor method for a GetNode response.
// A *Response is returned with the configured status code and content type from the spec.
func GetNodeJSON200Response(body K8sNode) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListPodsAllNamespacesJSON200Response is a constructor method for a ListPodsAllNamespaces response.
// A *Response is returned with the configured status code and content type from the spec.
func ListPodsAllNamespacesJSON200Response(body K8sPodList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListServiceAccountsJSON200Response is a constructor method for a ListServiceAccounts response.
// A *Response is returned with the configured status code and content type from the spec.
func ListServiceAccountsJSON200Response(body K8sServiceAccountList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetServiceAccountJSON200Response is a constructor method for a GetServiceAccount response.
// A *Response is returned with the configured status code and content type from the spec.
func GetServiceAccountJSON200Response(body K8sServiceAccount) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchServiceAccountJSON200Response is a constructor method for a PatchServiceAccount response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchServiceAccountJSON200Response(body K8sServiceAccount) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListServicesAllNamespacesJSON200Response is a constructor method for a ListServicesAllNamespaces response.
// A *Response is returned with the configured status code and content type from the spec.
func ListServicesAllNamespacesJSON200Response(body K8sServiceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetAPIVersionsJSON200Response is a constructor method for a GetAPIVersions response.
// A *Response is returned with the configured status code and content type from the spec.
func GetAPIVersionsJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIGroupList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetAppsV1apiResourcesJSON200Response is a constructor method for a GetAppsV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetAppsV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListDeploymentsJSON200Response is a constructor method for a ListDeployments response.
// A *Response is returned with the configured status code and content type from the spec.
func ListDeploymentsJSON200Response(body K8sDeploymentList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetDeploymentJSON200Response is a constructor method for a GetDeployment response.
// A *Response is returned with the configured status code and content type from the spec.
func GetDeploymentJSON200Response(body K8sDeployment) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchDeploymentJSON200Response is a constructor method for a PatchDeployment response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchDeploymentJSON200Response(body K8sDeployment) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetAuthorizationV1apiResourcesJSON200Response is a constructor method for a GetAuthorizationV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetAuthorizationV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetCertificatesV1apiResourcesJSON200Response is a constructor method for a GetCertificatesV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetCertificatesV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListCertificateSigningRequestsJSON200Response is a constructor method for a ListCertificateSigningRequests response.
// A *Response is returned with the configured status code and content type from the spec.
func ListCertificateSigningRequestsJSON200Response(body K8sCertificateSigningRequestList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetCertificateSigningRequestJSON200Response is a constructor method for a GetCertificateSigningRequest response.
// A *Response is returned with the configured status code and content type from the spec.
func GetCertificateSigningRequestJSON200Response(body K8sCertificateSigningRequest) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchCertificateSigningRequestJSON200Response is a constructor method for a PatchCertificateSigningRequest response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchCertificateSigningRequestJSON200Response(body K8sCertificateSigningRequest) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ApproveCertificateSigningRequestJSON200Response is a constructor method for a ApproveCertificateSigningRequest response.
// A *Response is returned with the configured status code and content type from the spec.
func ApproveCertificateSigningRequestJSON200Response(body K8sCertificateSigningRequest) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GenerateCertJSON200Response is a constructor method for a GenerateCert response.
// A *Response is returned with the configured status code and content type from the spec.
func GenerateCertJSON200Response(body KraudCertificateGenerateResponse) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetEventsV1apiResourcesJSON200Response is a constructor method for a GetEventsV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetEventsV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// VmmCradleStateJSON101Response is a constructor method for a VmmCradleState response.
// A *Response is returned with the configured status code and content type from the spec.
func VmmCradleStateJSON101Response(body KrCradleState) *Response {
	return &Response{
		body:        body,
		Code:        101,
		contentType: "application/json",
	}
}

// GetVmmLaunchSpecJSON200Response is a constructor method for a GetVmmLaunchSpec response.
// A *Response is returned with the configured status code and content type from the spec.
func GetVmmLaunchSpecJSON200Response(body map[string]interface{}) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetKraudcloudV1apiResourcesJSON200Response is a constructor method for a GetKraudcloudV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetKraudcloudV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetFeedsJSON200Response is a constructor method for a GetFeeds response.
// A *Response is returned with the configured status code and content type from the spec.
func GetFeedsJSON200Response(body KraudFeedList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// CreateFeedJSON200Response is a constructor method for a CreateFeed response.
// A *Response is returned with the configured status code and content type from the spec.
func CreateFeedJSON200Response(body KraudFeed) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetFeedAppsJSON200Response is a constructor method for a GetFeedApps response.
// A *Response is returned with the configured status code and content type from the spec.
func GetFeedAppsJSON200Response(body KraudFeed) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// LaunchAppJSON200Response is a constructor method for a LaunchApp response.
// A *Response is returned with the configured status code and content type from the spec.
func LaunchAppJSON200Response(body KraudLaunchAppResponse) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetFeedAppTemplateJSON200Response is a constructor method for a GetFeedAppTemplate response.
// A *Response is returned with the configured status code and content type from the spec.
func GetFeedAppTemplateJSON200Response(body KraudAppOverview) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetFeedAppVersionsJSON200Response is a constructor method for a GetFeedAppVersions response.
// A *Response is returned with the configured status code and content type from the spec.
func GetFeedAppVersionsJSON200Response(body KraudAppVersionList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListImagesJSON200Response is a constructor method for a ListImages response.
// A *Response is returned with the configured status code and content type from the spec.
func ListImagesJSON200Response(body KraudImageNameList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// CreateImageJSON200Response is a constructor method for a CreateImage response.
// A *Response is returned with the configured status code and content type from the spec.
func CreateImageJSON200Response(body KraudCreateImageResponse) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// AttachLaunchJSON101Response is a constructor method for a AttachLaunch response.
// A *Response is returned with the configured status code and content type from the spec.
func AttachLaunchJSON101Response(body interface{}) *Response {
	return &Response{
		body:        body,
		Code:        101,
		contentType: "application/json",
	}
}

// ListLayersJSON200Response is a constructor method for a ListLayers response.
// A *Response is returned with the configured status code and content type from the spec.
func ListLayersJSON200Response(body KraudLayerList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// WhoamiJSON200Response is a constructor method for a Whoami response.
// A *Response is returned with the configured status code and content type from the spec.
func WhoamiJSON200Response(body KraudSessionInfo) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListUsersJSON200Response is a constructor method for a ListUsers response.
// A *Response is returned with the configured status code and content type from the spec.
func ListUsersJSON200Response(body K8sUserList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// CreateUserJSON201Response is a constructor method for a CreateUser response.
// A *Response is returned with the configured status code and content type from the spec.
func CreateUserJSON201Response(body K8sUser) *Response {
	return &Response{
		body:        body,
		Code:        201,
		contentType: "application/json",
	}
}

// GetUserJSON200Response is a constructor method for a GetUser response.
// A *Response is returned with the configured status code and content type from the spec.
func GetUserJSON200Response(body K8sUser) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetNetworkingAPIResourcesJSON200Response is a constructor method for a GetNetworkingAPIResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetNetworkingAPIResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetNetworkingV1apiResourcesJSON200Response is a constructor method for a GetNetworkingV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetNetworkingV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListIngressClassesJSON200Response is a constructor method for a ListIngressClasses response.
// A *Response is returned with the configured status code and content type from the spec.
func ListIngressClassesJSON200Response(body K8sIngressClassList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetIngressClassJSON200Response is a constructor method for a GetIngressClass response.
// A *Response is returned with the configured status code and content type from the spec.
func GetIngressClassJSON200Response(body K8sIngressClass) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListIngressesJSON200Response is a constructor method for a ListIngresses response.
// A *Response is returned with the configured status code and content type from the spec.
func ListIngressesJSON200Response(body K8sIngressList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetIngressJSON200Response is a constructor method for a GetIngress response.
// A *Response is returned with the configured status code and content type from the spec.
func GetIngressJSON200Response(body K8sIngress) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// PatchIngressJSON200Response is a constructor method for a PatchIngress response.
// A *Response is returned with the configured status code and content type from the spec.
func PatchIngressJSON200Response(body K8sIngress) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetStorageV1apiResourcesJSON200Response is a constructor method for a GetStorageV1apiResources response.
// A *Response is returned with the configured status code and content type from the spec.
func GetStorageV1apiResourcesJSON200Response(body IoK8sApimachineryPkgApisMetaV1APIResourceList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// ListStorageClassesJSON200Response is a constructor method for a ListStorageClasses response.
// A *Response is returned with the configured status code and content type from the spec.
func ListStorageClassesJSON200Response(body K8sStorageClassList) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetStorageClassJSON200Response is a constructor method for a GetStorageClass response.
// A *Response is returned with the configured status code and content type from the spec.
func GetStorageClassJSON200Response(body K8sStorageClass) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerConfigListJSON200Response is a constructor method for a DockerConfigList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerConfigListJSON200Response(body []Config) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerContainerListJSON200Response is a constructor method for a DockerContainerList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerContainerListJSON200Response(body []ContainerSummary) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerContainerInspectJSON200Response is a constructor method for a DockerContainerInspect response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerContainerInspectJSON200Response(body ContainerInspectResponse) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerSystemVersionJSON200Response is a constructor method for a DockerSystemVersion response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerSystemVersionJSON200Response(body SystemVersion) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerSystemVersionJSON500Response is a constructor method for a DockerSystemVersion response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerSystemVersionJSON500Response(body ErrorResponse) *Response {
	return &Response{
		body:        body,
		Code:        500,
		contentType: "application/json",
	}
}

// DockerImageListJSON200Response is a constructor method for a DockerImageList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerImageListJSON200Response(body []ImageSummary) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerImageInspectJSON200Response is a constructor method for a DockerImageInspect response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerImageInspectJSON200Response(body ImageInspect) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerSystemInfoJSON200Response is a constructor method for a DockerSystemInfo response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerSystemInfoJSON200Response(body SystemInfo) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerNetworkListJSON200Response is a constructor method for a DockerNetworkList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerNetworkListJSON200Response(body []Network) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerNodeListJSON200Response is a constructor method for a DockerNodeList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerNodeListJSON200Response(body []Node) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerSecretListJSON200Response is a constructor method for a DockerSecretList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerSecretListJSON200Response(body []Secret) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerSecretCreateJSON201Response is a constructor method for a DockerSecretCreate response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerSecretCreateJSON201Response(body IDResponse) *Response {
	return &Response{
		body:        body,
		Code:        201,
		contentType: "application/json",
	}
}

// DockerServiceListJSON200Response is a constructor method for a DockerServiceList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerServiceListJSON200Response(body []Service) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerServiceListJSON500Response is a constructor method for a DockerServiceList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerServiceListJSON500Response(body ErrorResponse) *Response {
	return &Response{
		body:        body,
		Code:        500,
		contentType: "application/json",
	}
}

// DockerServiceListJSON503Response is a constructor method for a DockerServiceList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerServiceListJSON503Response(body ErrorResponse) *Response {
	return &Response{
		body:        body,
		Code:        503,
		contentType: "application/json",
	}
}

// DockerServiceInspectJSON200Response is a constructor method for a DockerServiceInspect response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerServiceInspectJSON200Response(body Service) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// GetCodeVersionJSON200Response is a constructor method for a GetCodeVersion response.
// A *Response is returned with the configured status code and content type from the spec.
func GetCodeVersionJSON200Response(body CodeVersionInfo) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerVolumeListJSON200Response is a constructor method for a DockerVolumeList response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerVolumeListJSON200Response(body struct {
	Volumes []Volume `json:"Volumes"`

	// Warnings that occurred when fetching the list of volumes.
	Warnings []string `json:"Warnings"`
}) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// DockerVolumeCreateJSON201Response is a constructor method for a DockerVolumeCreate response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerVolumeCreateJSON201Response(body Volume) *Response {
	return &Response{
		body:        body,
		Code:        201,
		contentType: "application/json",
	}
}

// DockerVolumeInspectJSON200Response is a constructor method for a DockerVolumeInspect response.
// A *Response is returned with the configured status code and content type from the spec.
func DockerVolumeInspectJSON200Response(body Volume) *Response {
	return &Response{
		body:        body,
		Code:        200,
		contentType: "application/json",
	}
}

// Getter for additional properties for ConfigSpec_Labels. Returns the specified
// element and whether it was found
func (a ConfigSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConfigSpec_Labels
func (a *ConfigSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConfigSpec_Labels to handle AdditionalProperties
func (a *ConfigSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConfigSpec_Labels to handle AdditionalProperties
func (a ConfigSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_ExposedPorts. Returns the specified
// element and whether it was found
func (a ContainerConfig_ExposedPorts) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_ExposedPorts
func (a *ContainerConfig_ExposedPorts) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_ExposedPorts to handle AdditionalProperties
func (a *ContainerConfig_ExposedPorts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_ExposedPorts to handle AdditionalProperties
func (a ContainerConfig_ExposedPorts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_Labels. Returns the specified
// element and whether it was found
func (a ContainerConfig_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_Labels
func (a *ContainerConfig_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_Labels to handle AdditionalProperties
func (a *ContainerConfig_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_Labels to handle AdditionalProperties
func (a ContainerConfig_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerConfig_Volumes. Returns the specified
// element and whether it was found
func (a ContainerConfig_Volumes) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerConfig_Volumes
func (a *ContainerConfig_Volumes) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerConfig_Volumes to handle AdditionalProperties
func (a *ContainerConfig_Volumes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerConfig_Volumes to handle AdditionalProperties
func (a ContainerConfig_Volumes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerSummary_Labels. Returns the specified
// element and whether it was found
func (a ContainerSummary_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerSummary_Labels
func (a *ContainerSummary_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerSummary_Labels to handle AdditionalProperties
func (a *ContainerSummary_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerSummary_Labels to handle AdditionalProperties
func (a ContainerSummary_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ContainerSummary_NetworkSettings_Networks. Returns the specified
// element and whether it was found
func (a ContainerSummary_NetworkSettings_Networks) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ContainerSummary_NetworkSettings_Networks
func (a *ContainerSummary_NetworkSettings_Networks) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ContainerSummary_NetworkSettings_Networks to handle AdditionalProperties
func (a *ContainerSummary_NetworkSettings_Networks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ContainerSummary_NetworkSettings_Networks to handle AdditionalProperties
func (a ContainerSummary_NetworkSettings_Networks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DeviceRequest_Options. Returns the specified
// element and whether it was found
func (a DeviceRequest_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeviceRequest_Options
func (a *DeviceRequest_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeviceRequest_Options to handle AdditionalProperties
func (a *DeviceRequest_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeviceRequest_Options to handle AdditionalProperties
func (a DeviceRequest_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Driver_Options. Returns the specified
// element and whether it was found
func (a Driver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Driver_Options
func (a *Driver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Driver_Options to handle AdditionalProperties
func (a *Driver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Driver_Options to handle AdditionalProperties
func (a Driver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EndpointSettings_DriverOpts. Returns the specified
// element and whether it was found
func (a EndpointSettings_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EndpointSettings_DriverOpts
func (a *EndpointSettings_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EndpointSettings_DriverOpts to handle AdditionalProperties
func (a *EndpointSettings_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EndpointSettings_DriverOpts to handle AdditionalProperties
func (a EndpointSettings_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EngineDescription_Labels. Returns the specified
// element and whether it was found
func (a EngineDescription_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EngineDescription_Labels
func (a *EngineDescription_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EngineDescription_Labels to handle AdditionalProperties
func (a *EngineDescription_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EngineDescription_Labels to handle AdditionalProperties
func (a EngineDescription_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GraphDriverData_Data. Returns the specified
// element and whether it was found
func (a GraphDriverData_Data) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GraphDriverData_Data
func (a *GraphDriverData_Data) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GraphDriverData_Data to handle AdditionalProperties
func (a *GraphDriverData_Data) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GraphDriverData_Data to handle AdditionalProperties
func (a GraphDriverData_Data) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_LogConfig_Config. Returns the specified
// element and whether it was found
func (a HostConfig_LogConfig_Config) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_LogConfig_Config
func (a *HostConfig_LogConfig_Config) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_LogConfig_Config to handle AdditionalProperties
func (a *HostConfig_LogConfig_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_LogConfig_Config to handle AdditionalProperties
func (a HostConfig_LogConfig_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_StorageOpt. Returns the specified
// element and whether it was found
func (a HostConfig_StorageOpt) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_StorageOpt
func (a *HostConfig_StorageOpt) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_StorageOpt to handle AdditionalProperties
func (a *HostConfig_StorageOpt) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_StorageOpt to handle AdditionalProperties
func (a HostConfig_StorageOpt) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_Sysctls. Returns the specified
// element and whether it was found
func (a HostConfig_Sysctls) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_Sysctls
func (a *HostConfig_Sysctls) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_Sysctls to handle AdditionalProperties
func (a *HostConfig_Sysctls) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_Sysctls to handle AdditionalProperties
func (a HostConfig_Sysctls) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HostConfig_Tmpfs. Returns the specified
// element and whether it was found
func (a HostConfig_Tmpfs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HostConfig_Tmpfs
func (a *HostConfig_Tmpfs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HostConfig_Tmpfs to handle AdditionalProperties
func (a *HostConfig_Tmpfs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HostConfig_Tmpfs to handle AdditionalProperties
func (a HostConfig_Tmpfs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IPAM_Options. Returns the specified
// element and whether it was found
func (a IPAM_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IPAM_Options
func (a *IPAM_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IPAM_Options to handle AdditionalProperties
func (a *IPAM_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IPAM_Options to handle AdditionalProperties
func (a IPAM_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IPAMConfig_AuxiliaryAddresses. Returns the specified
// element and whether it was found
func (a IPAMConfig_AuxiliaryAddresses) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IPAMConfig_AuxiliaryAddresses
func (a *IPAMConfig_AuxiliaryAddresses) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IPAMConfig_AuxiliaryAddresses to handle AdditionalProperties
func (a *IPAMConfig_AuxiliaryAddresses) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IPAMConfig_AuxiliaryAddresses to handle AdditionalProperties
func (a IPAMConfig_AuxiliaryAddresses) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ImageSummary_Labels. Returns the specified
// element and whether it was found
func (a ImageSummary_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ImageSummary_Labels
func (a *ImageSummary_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ImageSummary_Labels to handle AdditionalProperties
func (a *ImageSummary_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ImageSummary_Labels to handle AdditionalProperties
func (a ImageSummary_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Mount_VolumeOptions_DriverConfig_Options. Returns the specified
// element and whether it was found
func (a Mount_VolumeOptions_DriverConfig_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Mount_VolumeOptions_DriverConfig_Options
func (a *Mount_VolumeOptions_DriverConfig_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Mount_VolumeOptions_DriverConfig_Options to handle AdditionalProperties
func (a *Mount_VolumeOptions_DriverConfig_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Mount_VolumeOptions_DriverConfig_Options to handle AdditionalProperties
func (a Mount_VolumeOptions_DriverConfig_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Mount_VolumeOptions_Labels. Returns the specified
// element and whether it was found
func (a Mount_VolumeOptions_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Mount_VolumeOptions_Labels
func (a *Mount_VolumeOptions_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Mount_VolumeOptions_Labels to handle AdditionalProperties
func (a *Mount_VolumeOptions_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Mount_VolumeOptions_Labels to handle AdditionalProperties
func (a Mount_VolumeOptions_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Containers. Returns the specified
// element and whether it was found
func (a Network_Containers) Get(fieldName string) (value NetworkContainer, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Containers
func (a *Network_Containers) Set(fieldName string, value NetworkContainer) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]NetworkContainer)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Containers to handle AdditionalProperties
func (a *Network_Containers) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]NetworkContainer)
		for fieldName, fieldBuf := range object {
			var fieldVal NetworkContainer
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Containers to handle AdditionalProperties
func (a Network_Containers) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Labels. Returns the specified
// element and whether it was found
func (a Network_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Labels
func (a *Network_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Labels to handle AdditionalProperties
func (a *Network_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Labels to handle AdditionalProperties
func (a Network_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Network_Options. Returns the specified
// element and whether it was found
func (a Network_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Network_Options
func (a *Network_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Network_Options to handle AdditionalProperties
func (a *Network_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Network_Options to handle AdditionalProperties
func (a Network_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkAttachmentConfig_DriverOpts. Returns the specified
// element and whether it was found
func (a NetworkAttachmentConfig_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkAttachmentConfig_DriverOpts
func (a *NetworkAttachmentConfig_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkAttachmentConfig_DriverOpts to handle AdditionalProperties
func (a *NetworkAttachmentConfig_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkAttachmentConfig_DriverOpts to handle AdditionalProperties
func (a NetworkAttachmentConfig_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkSettings_Networks. Returns the specified
// element and whether it was found
func (a NetworkSettings_Networks) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkSettings_Networks
func (a *NetworkSettings_Networks) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkSettings_Networks to handle AdditionalProperties
func (a *NetworkSettings_Networks) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkSettings_Networks to handle AdditionalProperties
func (a NetworkSettings_Networks) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkingConfig_EndpointsConfig. Returns the specified
// element and whether it was found
func (a NetworkingConfig_EndpointsConfig) Get(fieldName string) (value EndpointSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkingConfig_EndpointsConfig
func (a *NetworkingConfig_EndpointsConfig) Set(fieldName string, value EndpointSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EndpointSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkingConfig_EndpointsConfig to handle AdditionalProperties
func (a *NetworkingConfig_EndpointsConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EndpointSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal EndpointSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkingConfig_EndpointsConfig to handle AdditionalProperties
func (a NetworkingConfig_EndpointsConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NodeSpec_Labels. Returns the specified
// element and whether it was found
func (a NodeSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NodeSpec_Labels
func (a *NodeSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NodeSpec_Labels to handle AdditionalProperties
func (a *NodeSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NodeSpec_Labels to handle AdditionalProperties
func (a NodeSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PortMap. Returns the specified
// element and whether it was found
func (a PortMap) Get(fieldName string) (value []PortBinding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PortMap
func (a *PortMap) Set(fieldName string, value []PortBinding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]PortBinding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PortMap to handle AdditionalProperties
func (a *PortMap) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]PortBinding)
		for fieldName, fieldBuf := range object {
			var fieldVal []PortBinding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PortMap to handle AdditionalProperties
func (a PortMap) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegistryServiceConfig_IndexConfigs. Returns the specified
// element and whether it was found
func (a RegistryServiceConfig_IndexConfigs) Get(fieldName string) (value IndexInfo, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegistryServiceConfig_IndexConfigs
func (a *RegistryServiceConfig_IndexConfigs) Set(fieldName string, value IndexInfo) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]IndexInfo)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegistryServiceConfig_IndexConfigs to handle AdditionalProperties
func (a *RegistryServiceConfig_IndexConfigs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]IndexInfo)
		for fieldName, fieldBuf := range object {
			var fieldVal IndexInfo
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegistryServiceConfig_IndexConfigs to handle AdditionalProperties
func (a RegistryServiceConfig_IndexConfigs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SecretSpec_Labels. Returns the specified
// element and whether it was found
func (a SecretSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SecretSpec_Labels
func (a *SecretSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SecretSpec_Labels to handle AdditionalProperties
func (a *SecretSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SecretSpec_Labels to handle AdditionalProperties
func (a SecretSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ServiceSpec_Labels. Returns the specified
// element and whether it was found
func (a ServiceSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ServiceSpec_Labels
func (a *ServiceSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ServiceSpec_Labels to handle AdditionalProperties
func (a *ServiceSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ServiceSpec_Labels to handle AdditionalProperties
func (a ServiceSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_CAConfig_ExternalCAs_Options. Returns the specified
// element and whether it was found
func (a SwarmSpec_CAConfig_ExternalCAs_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_CAConfig_ExternalCAs_Options
func (a *SwarmSpec_CAConfig_ExternalCAs_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_CAConfig_ExternalCAs_Options to handle AdditionalProperties
func (a *SwarmSpec_CAConfig_ExternalCAs_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_CAConfig_ExternalCAs_Options to handle AdditionalProperties
func (a SwarmSpec_CAConfig_ExternalCAs_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_Labels. Returns the specified
// element and whether it was found
func (a SwarmSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_Labels
func (a *SwarmSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_Labels to handle AdditionalProperties
func (a *SwarmSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_Labels to handle AdditionalProperties
func (a SwarmSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SwarmSpec_TaskDefaults_LogDriver_Options. Returns the specified
// element and whether it was found
func (a SwarmSpec_TaskDefaults_LogDriver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SwarmSpec_TaskDefaults_LogDriver_Options
func (a *SwarmSpec_TaskDefaults_LogDriver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SwarmSpec_TaskDefaults_LogDriver_Options to handle AdditionalProperties
func (a *SwarmSpec_TaskDefaults_LogDriver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SwarmSpec_TaskDefaults_LogDriver_Options to handle AdditionalProperties
func (a SwarmSpec_TaskDefaults_LogDriver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SystemInfo_Runtimes. Returns the specified
// element and whether it was found
func (a SystemInfo_Runtimes) Get(fieldName string) (value Runtime, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SystemInfo_Runtimes
func (a *SystemInfo_Runtimes) Set(fieldName string, value Runtime) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Runtime)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SystemInfo_Runtimes to handle AdditionalProperties
func (a *SystemInfo_Runtimes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Runtime)
		for fieldName, fieldBuf := range object {
			var fieldVal Runtime
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SystemInfo_Runtimes to handle AdditionalProperties
func (a SystemInfo_Runtimes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpec_LogDriver_Options. Returns the specified
// element and whether it was found
func (a TaskSpec_LogDriver_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpec_LogDriver_Options
func (a *TaskSpec_LogDriver_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpec_LogDriver_Options to handle AdditionalProperties
func (a *TaskSpec_LogDriver_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpec_LogDriver_Options to handle AdditionalProperties
func (a TaskSpec_LogDriver_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpecContainerSpec_Labels. Returns the specified
// element and whether it was found
func (a TaskSpecContainerSpec_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpecContainerSpec_Labels
func (a *TaskSpecContainerSpec_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpecContainerSpec_Labels to handle AdditionalProperties
func (a *TaskSpecContainerSpec_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpecContainerSpec_Labels to handle AdditionalProperties
func (a TaskSpecContainerSpec_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSpecContainerSpec_Sysctls. Returns the specified
// element and whether it was found
func (a TaskSpecContainerSpec_Sysctls) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSpecContainerSpec_Sysctls
func (a *TaskSpecContainerSpec_Sysctls) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSpecContainerSpec_Sysctls to handle AdditionalProperties
func (a *TaskSpecContainerSpec_Sysctls) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSpecContainerSpec_Sysctls to handle AdditionalProperties
func (a TaskSpecContainerSpec_Sysctls) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Labels. Returns the specified
// element and whether it was found
func (a Volume_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Labels
func (a *Volume_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Labels to handle AdditionalProperties
func (a *Volume_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Labels to handle AdditionalProperties
func (a Volume_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Options. Returns the specified
// element and whether it was found
func (a Volume_Options) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Options
func (a *Volume_Options) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Options to handle AdditionalProperties
func (a *Volume_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Options to handle AdditionalProperties
func (a Volume_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Volume_Status. Returns the specified
// element and whether it was found
func (a Volume_Status) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Volume_Status
func (a *Volume_Status) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Volume_Status to handle AdditionalProperties
func (a *Volume_Status) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Volume_Status to handle AdditionalProperties
func (a Volume_Status) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VolumeCreateOptions_DriverOpts. Returns the specified
// element and whether it was found
func (a VolumeCreateOptions_DriverOpts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VolumeCreateOptions_DriverOpts
func (a *VolumeCreateOptions_DriverOpts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VolumeCreateOptions_DriverOpts to handle AdditionalProperties
func (a *VolumeCreateOptions_DriverOpts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VolumeCreateOptions_DriverOpts to handle AdditionalProperties
func (a VolumeCreateOptions_DriverOpts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VolumeCreateOptions_Labels. Returns the specified
// element and whether it was found
func (a VolumeCreateOptions_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VolumeCreateOptions_Labels
func (a *VolumeCreateOptions_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VolumeCreateOptions_Labels to handle AdditionalProperties
func (a *VolumeCreateOptions_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VolumeCreateOptions_Labels to handle AdditionalProperties
func (a VolumeCreateOptions_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations. Returns the specified
// element and whether it was found
func (a IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations
func (a *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations to handle AdditionalProperties
func (a *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations to handle AdditionalProperties
func (a IoK8sApimachineryPkgApisMetaV1ObjectMeta_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels. Returns the specified
// element and whether it was found
func (a IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels
func (a *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels to handle AdditionalProperties
func (a *IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels to handle AdditionalProperties
func (a IoK8sApimachineryPkgApisMetaV1ObjectMeta_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sConfigMap_BinaryData. Returns the specified
// element and whether it was found
func (a K8sConfigMap_BinaryData) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sConfigMap_BinaryData
func (a *K8sConfigMap_BinaryData) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sConfigMap_BinaryData to handle AdditionalProperties
func (a *K8sConfigMap_BinaryData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sConfigMap_BinaryData to handle AdditionalProperties
func (a K8sConfigMap_BinaryData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sConfigMap_Data. Returns the specified
// element and whether it was found
func (a K8sConfigMap_Data) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sConfigMap_Data
func (a *K8sConfigMap_Data) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sConfigMap_Data to handle AdditionalProperties
func (a *K8sConfigMap_Data) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sConfigMap_Data to handle AdditionalProperties
func (a K8sConfigMap_Data) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sDeploymentSpec_Selector. Returns the specified
// element and whether it was found
func (a K8sDeploymentSpec_Selector) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sDeploymentSpec_Selector
func (a *K8sDeploymentSpec_Selector) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sDeploymentSpec_Selector to handle AdditionalProperties
func (a *K8sDeploymentSpec_Selector) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sDeploymentSpec_Selector to handle AdditionalProperties
func (a K8sDeploymentSpec_Selector) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sResourceRequirements_Limits. Returns the specified
// element and whether it was found
func (a K8sResourceRequirements_Limits) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sResourceRequirements_Limits
func (a *K8sResourceRequirements_Limits) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sResourceRequirements_Limits to handle AdditionalProperties
func (a *K8sResourceRequirements_Limits) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sResourceRequirements_Limits to handle AdditionalProperties
func (a K8sResourceRequirements_Limits) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sResourceRequirements_Requests. Returns the specified
// element and whether it was found
func (a K8sResourceRequirements_Requests) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sResourceRequirements_Requests
func (a *K8sResourceRequirements_Requests) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sResourceRequirements_Requests to handle AdditionalProperties
func (a *K8sResourceRequirements_Requests) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sResourceRequirements_Requests to handle AdditionalProperties
func (a K8sResourceRequirements_Requests) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sSecret_BinaryData. Returns the specified
// element and whether it was found
func (a K8sSecret_BinaryData) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sSecret_BinaryData
func (a *K8sSecret_BinaryData) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sSecret_BinaryData to handle AdditionalProperties
func (a *K8sSecret_BinaryData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sSecret_BinaryData to handle AdditionalProperties
func (a K8sSecret_BinaryData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sSecret_Data. Returns the specified
// element and whether it was found
func (a K8sSecret_Data) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sSecret_Data
func (a *K8sSecret_Data) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sSecret_Data to handle AdditionalProperties
func (a *K8sSecret_Data) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sSecret_Data to handle AdditionalProperties
func (a K8sSecret_Data) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sServiceSpec_Selector. Returns the specified
// element and whether it was found
func (a K8sServiceSpec_Selector) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sServiceSpec_Selector
func (a *K8sServiceSpec_Selector) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sServiceSpec_Selector to handle AdditionalProperties
func (a *K8sServiceSpec_Selector) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sServiceSpec_Selector to handle AdditionalProperties
func (a K8sServiceSpec_Selector) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for K8sStorageClass_Parameters. Returns the specified
// element and whether it was found
func (a K8sStorageClass_Parameters) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for K8sStorageClass_Parameters
func (a *K8sStorageClass_Parameters) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for K8sStorageClass_Parameters to handle AdditionalProperties
func (a *K8sStorageClass_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for K8sStorageClass_Parameters to handle AdditionalProperties
func (a K8sStorageClass_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KraudAppOverview_Config. Returns the specified
// element and whether it was found
func (a KraudAppOverview_Config) Get(fieldName string) (value KraudAppTemplateConfig, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KraudAppOverview_Config
func (a *KraudAppOverview_Config) Set(fieldName string, value KraudAppTemplateConfig) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]KraudAppTemplateConfig)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KraudAppOverview_Config to handle AdditionalProperties
func (a *KraudAppOverview_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]KraudAppTemplateConfig)
		for fieldName, fieldBuf := range object {
			var fieldVal KraudAppTemplateConfig
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KraudAppOverview_Config to handle AdditionalProperties
func (a KraudAppOverview_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KraudAppTemplateConfig. Returns the specified
// element and whether it was found
func (a KraudAppTemplateConfig) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KraudAppTemplateConfig
func (a *KraudAppTemplateConfig) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KraudAppTemplateConfig to handle AdditionalProperties
func (a *KraudAppTemplateConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &a.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
		delete(object, "kind")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["required"]; found {
		err = json.Unmarshal(raw, &a.Required)
		if err != nil {
			return fmt.Errorf("error reading 'required': %w", err)
		}
		delete(object, "required")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KraudAppTemplateConfig to handle AdditionalProperties
func (a KraudAppTemplateConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["default"], err = json.Marshal(a.Default)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'default': %w", err)
	}

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["kind"], err = json.Marshal(a.Kind)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'kind': %w", err)
	}

	object["label"], err = json.Marshal(a.Label)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'label': %w", err)
	}

	object["required"], err = json.Marshal(a.Required)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'required': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KraudLaunchSettings_Config. Returns the specified
// element and whether it was found
func (a KraudLaunchSettings_Config) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KraudLaunchSettings_Config
func (a *KraudLaunchSettings_Config) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KraudLaunchSettings_Config to handle AdditionalProperties
func (a *KraudLaunchSettings_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KraudLaunchSettings_Config to handle AdditionalProperties
func (a KraudLaunchSettings_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
